# 2.9 ì¸í„°í˜ì´ìŠ¤ë¡œ ê°ì²´ë¥¼ íƒ€ì´í•‘í•˜ì.

ì¸í„°í˜ì´ìŠ¤(interface) ì„ ì–¸ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒ. ì´ë¦„ì€ íƒ€ì… ë³„ì¹­ê³¼ ë§ˆì°¬ê°€ì§€ë¡œ ëŒ€ë¬¸ìë¡œ ì‹œì‘í•˜ëŠ” ë‹¨ì–´ë¥¼ ë§Œë“œëŠ” ê²ƒì´ ê´€ë¡€.
ì¸í„°í˜ì´ìŠ¤ë¥¼ ì…ë ¥í•  ë•Œ ì½¤ë§ˆë‚˜ ì„¸ë¯¸ì½œë¡ , ì¤„ë°”ê¿ˆìœ¼ë¡œ êµ¬ë¶„í•  ìˆ˜ ìˆëŠ”ë° í•œê°€ì§€ ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ê²ƒì€ ê¶Œì¥í•œë‹¤.

```typescript
interface Arr {
  length: number;
  [key: number]: string;
}

const arr: Arr = ["3", "5", "7"];

arr.slice();
// Error: Property 'slice' does not exist on type 'Arr'.
```

ì¸ë±ìŠ¤ ì‹œê·¸ë‹ˆì²˜(Index Signature) : ì´ ê°ì²´ì˜ lengthë¥¼ ì œì™¸í•œ ì†ì„± í‚¤ê°€ ì „ë¶€ numberë¼ëŠ” ì˜ë¯¸ì´ë‹¤. Arr ì¸í„°í˜ì´ìŠ¤ëŠ” ë°°ì—´ì„ ì •í™•í•˜ê²Œ êµ¬í˜„í•œ ê²ƒì´ ì•„ë‹ˆë¯€ë¡œ ë°°ì—´ ë‚´ì¥ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ë‹¤.
ë‚´ì¥ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ë°©ë²•ì€ 2.10ì—ì„œ ì•Œì•„ë³´ì.

## 2.9.1 ì¸í„°í˜ì´ìŠ¤ ì„ ì–¸ ë³‘í•©

ê°™ì€ ì´ë¦„ìœ¼ë¡œ ì—¬ëŸ¬ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤. ëŒ€ì‹  í•˜ë‚˜ë¡œ í•©ì³ì§„ë‹¤.

## 2.9.2 ë„¤ì„ìŠ¤í˜ì´ìŠ¤

ê°™ì€ ì´ë¦„ì„ ì‚¬ìš©í•˜ë©´ ì¸í„°í˜ì´ìŠ¤ê°€ ë³‘í•©ë˜ì–´ ì›í•˜ì§€ ì•ŠëŠ” ê²°ê³¼ë¥¼ ë‚³ê²Œ ëœë‹¤. ë„¤ì„ìŠ¤í˜ì´ìŠ¤(namespace)ë¥¼ ì‚¬ìš©í•˜ë©´ ê°ì²´ì²˜ëŸ¼ ì ‘ê·¼í•˜ì—¬ ì‚¬ìš©ê°€ëŠ¥í•˜ë‹¤. ë‹¨, ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì•ˆì— ê°ì²´ë¥¼ exportë¥¼ í•´ì•¼ í•œë‹¤.

ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ë‚´ë¶€ì— ì‹¤ì œ ê°’ì„ ì„ ì–¸í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. `[]`ë¥¼ ì‚¬ìš©í•´ì„œ ì ‘ê·¼í•  ìˆ˜ ìˆìœ¼ë‚˜ íƒ€ì…ì´ë‚˜ ì¸í„°í˜ì´ìŠ¤ëŠ” `[]`ë¥¼ ì‚¬ìš©í•´ì„œ ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤.

```typescript
namespace Example {
  export interface Inner {
    test: string;
  }
  export type test2 = number;
  export const a = "real";
}

const ex1: Example.Inner = {
  test: "hi",
};
const ex2: Example.test2 = 3;
const ex3 = Example.a;
const ex4 = Example["a"];
// âŒ
const ex5: Example["test2"] = 5;
// Cannot use namespace 'Example' as a type.
```

ë„¤ì„ìŠ¤í˜ì´ìŠ¤ë„ ì´ë¦„ì´ ê²¹ì¹˜ëŠ” ê²½ìš° ë³‘í•©ì´ ëœë‹¤.
ë‚´ë¶€ì— ê°™ì€ ì´ë¦„ì˜ ì¸í„°í˜ì´ìŠ¤ê°€ ìˆìœ¼ë©´ í•©ì³ì§€ê³ , ë‚´ë¶€ì— ê°™ì€ ì´ë¦„ì˜ íƒ€ì…ì´ ìˆë‹¤ë©´ ì—ëŸ¬ê°€ ë‚œë‹¤.

# 2.10 ê°ì²´ì˜ ì†ì„±ê³¼ ë©”ì„œë“œì— ì ìš©ë˜ëŠ” íŠ¹ì§•ì„ ì•Œì

ê°ì²´ì˜ ì†ì„±ì— ì ìš©ë˜ëŠ” íŠ¹ì§•ì€ ì¸í„°í˜ì´ìŠ¤ë¡œ ì„ ì–¸í–ˆë“ , íƒ€ì… ë³„ì¹­ìœ¼ë¡œ ì„ ì–¸í–ˆë“  ìƒê´€ì—†ì´ ê³µí†µì ìœ¼ë¡œ ì ìš©ëœë‹¤.

ì˜µì…”ë„(optional)ì´ë‚˜ readonly ìˆ˜ì‹ì–´ê°€ ê°€ëŠ¥í•˜ë‹¤.

```typescript
// ì „ê°œ ë¬¸ë²•ê³¼ ë‚˜ë¨¸ì§€ ì†ì„±
const {
  prop: { nested, ...rest },
} = { prop: { nested: "hi", a: 1, b: true } };
const spread = { a: "hi", b: 123 };
const obj = { ...spread };

// êµ¬ì¡°ë¶„í•´ í• ë‹¹í•  ë•Œ ë§ì´ ì‹¤ìˆ˜í•˜ëŠ” ê²ƒ
// âŒ ì˜ëª»ëœ ì˜ˆì‹œ
const {
  prop: { nested: string },
} = {
  prop: { nested: "hi" },
};
// const string: string

// ğŸ‘ ì˜¬ë°”ë¥¸ ì˜ˆì‹œ
const {
  prop: { nested },
}: { prop: { nested: string } } = {
  prop: { nested: "hi" },
};
```

ê¸°ë³¸ì ìœ¼ë¡œ ê°ì²´ë¥¼ íƒ€ì´í•‘í•  ë•Œ (ê°ì²´ ë¦¬í„°ëŸ´ ëŒ€ì…) ì„ ì–¸í•˜ì§€ ì•Šì€ ì†ì„±ì— ëŒ€í•´ì„œëŠ” ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ë§Œ ë³€ìˆ˜ë¥¼ ëŒ€ì…í–ˆì„ ë•ŒëŠ” ì—ëŸ¬ê°€ ë°œìƒí•˜ì§€ ì•ŠëŠ”ë‹¤. ê·¸ ì´ìœ ëŠ” ê°ì²´ ë¦¬í„°ëŸ´ì„ ëŒ€ì…í–ˆì„ ë•Œ íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ê°€ ì‰ì—¬ ì†ì„± ê²€ì‚¬(Excess Property Checking)ë¥¼ ì‹¤í–‰í•˜ê¸° ë•Œë¬¸ì´ë‹¤. ì‰ì—¬ ì†ì„± ê²€ì‚¬ëŠ” íƒ€ì… ì„ ì–¸ì—ì„œ ì„ ì–¸í•˜ì§€ ì•Šì€ ì†ì„±ì„ ì‚¬ìš©í•  ë•Œ ì—ëŸ¬ë¥¼ í‘œì‹œí•˜ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.

## 2.10.1 ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…

```typescript
type Animal = {
  name: string;
};
// âŒ ì˜ëª»ëœ ì˜ˆì‹œ
type N3 = Animal.name;
// type N3 = Animal['name']
```

íŠ¹ì • ì†ì„±ì˜ íƒ€ì…ì„ ë³„ë„ íƒ€ì…ìœ¼ë¡œ ë§Œë“¤ê³  ì‹¶ë‹¤ë©´ `ê°ì²´["ì†ì„±"]` ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼í•´ì•¼ í•œë‹¤. `ê°ì²´.ì†ì„±` ë°©ì‹ìœ¼ë¡œ ì ‘ê·¼í•  ìˆ˜ ì—†ë‹¤. ì´ë ‡ê²Œ ê°ì²´ ì†ì„±ì˜ íƒ€ì…ì— ì ‘ê·¼í•˜ëŠ” ë°©ì‹ì„ ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…(Indexed Acess Type)ì´ë¼ê³  í•œë‹¤.

```typescript
const obj = {
  hello: "world",
  name: "zero",
  age: 28,
};
type Keys = keyof typeof obj;
// type Keys = "hello" | "name" | "age"
type Values = (typeof obj)[Keys];
// type Values = string | number
```

keyof ì—°ì‚°ìì™€ ì¸ë±ìŠ¤ ì ‘ê·¼ íƒ€ì…ì„ í™œìš©í•´ í‚¤ì˜ íƒ€ì…ê³¼ ê°’ì˜ íƒ€ì…ì„ êµ¬í•  ìˆ˜ ìˆë‹¤.

```typescript
interface Examples {
  a(): void; // ë©”ì„œë“œ(ë§¤ê°œë³€ìˆ˜): ë°˜í™˜ê°’
  b: () => void; // ë©”ì„œë“œ: (ë§¤ê°œë³€ìˆ˜) => ë°˜í™˜ê°’
  c: {
    // ë©”ì„œë“œ:{ (ë§¤ê°œë³€ìˆ˜): ë°˜í™˜ê°’ }
    (): void;
  };
}
```

ê°ì²´ì˜ ë©”ì„œë“œë¥¼ ì„ ì–¸í•  ë•ŒëŠ” ì„¸ê°€ì§€ ë°©ì‹ìœ¼ë¡œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.

## 2.10.2 ë§¤í•‘ëœ ê°ì²´ íƒ€ì…

ê°ì²´ì˜ ì¼ë¶€ ì†ì„±ë§Œ íƒ€ì…ì„ ì§€ì •í•  ìˆ˜ ìˆë‹¤.

ë§¤í•‘ëœ ê°ì²´ íƒ€ì…(Mapped Object Type) ê¸°ëŠ¥ì„ ì‚¬ìš©í•˜ì—¬ ê¸°ì¡´ ê°ì²´ íƒ€ì…ì„ ê¸°ë°˜ìœ¼ë¡œ ìƒˆë¡œìš´ ê°ì²´ íƒ€ì…ì„ ë§Œë“¤ ìˆ˜ ìˆë‹¤. `keyof` ì™€ í•¨ê»˜ ì‚¬ìš©ë˜ë©° ê°ì²´ íƒ€ì…ì˜ í‚¤(í”„ë¡œí¼í‹° ì´ë¦„)ë¥¼ ì¶”ì¶œí•˜ëŠ”ë° ì‚¬ìš©ëœë‹¤.

ì½”ë“œë¥¼ ë°˜ë³µí•˜ì§€ ì•Šê³  ì„ íƒì ìœ¼ë¡œ ë§Œë“¤ ìˆ˜ ìˆë‹¤.

```ts
type Person = {
  name: string;
  age: number;
  location: string;
};

// ëª¨ë“  í”„ë¡œí¼í‹°ë¥¼ ì„ íƒì ìœ¼ë¡œ ë§Œë“œëŠ” ë§¤í•‘ëœ ê°ì²´ íƒ€ì…
type PartialPerson = {
  [key in keyof Person]?: Person[key];
};

// PartialPerson íƒ€ì… ì‚¬ìš©
const partialPerson: PartialPerson = {
  name: "Alice",
  age: 30,
};

// ìˆ˜ì‹ì–´ readonlyì™€ ? ì‚¬ìš©
type Copy = {
  readonly [key in keyof Person]?: Person[key];
};
/*
	type Copy = {
	    readonly name?: string | undefined;
	    readonly age?: number | undefined;
	    readonly location?: string | undefined;
	}
*/

// ìˆ˜ì‹ì–´ ì œê±°í•˜ëŠ” ë°©ë²•
type Remove = {
  -readonly [key in keyof Copy]-?: Copy[key];
};
/*
	ìˆ˜ì‹ì–´ `readonly`ì™€ `?` ì•ì— `-`ë¥¼ ë¶™ì—¬ì„œ readonlyì™€ ? ìˆ˜ì‹ì–´ê°€ ì œê±°ë˜ì—ˆë‹¤.
	type ìˆ˜ì‹ì–´ì œê±° = {
	    name: string;
	    age: number;
	    location: string;
	}
*/

// as ì˜ˆì•½ì–´ë¥¼ í†µí•´ ì†ì„± ì´ë¦„ì„ ë°”ê¿€ì§€ ì •í•  ìˆ˜ ìˆë‹¤.
// CapitalizeëŠ” íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ì œê³µí•˜ëŠ” íƒ€ì…ìœ¼ë¡œ ë¬¸ìì—´ì˜ ì²« ë²ˆì§¸ ìë¦¬ë¥¼ ëŒ€ë¬¸ìí™”í•œë‹¤.
// keyê°€ ì„œë²„ì—ì„œëŠ” ëŒ€ë¬¸ìë¡œ ë‚´ë ¤ì˜¤ê³  í”„ë¡ íŠ¸ì—ì„œëŠ” ì†Œë¬¸ìë¡œ ë‚´ë ¤ì˜¬ ë•Œ ì“°ë©´ ì¢‹ì„ ê²ƒ ê°™ë‹¤.
type CapitalizeCopy = {
  [key in keyof Person as Capitalize<key>]: Person[key];
};
/*
	type CapitalizeCopy = {  
		Name: string;  
		Age: number;  
		Location: string;  
	}
*/
```

# 2.11 íƒ€ì…ì„ ì§‘í•©ìœ¼ë¡œ ìƒê°í•˜ì (ìœ ë‹ˆì–¸, ì¸í„°ì„¹ì…˜)

êµì§‘í•©ì„ ë‚˜íƒ€ë‚´ëŠ” ì—°ì‚°ìëŠ” `&`ì´ë‹¤. íƒ€ì…ì„ ì§‘í•©ìœ¼ë¡œ ìƒê°í•˜ë©´ ì „ì²´ì§‘í•©ì€ unknown, ê³µì§‘í•©ì€ neverë¡œ ìƒê°í•  ìˆ˜ ìˆë‹¤. &ì€ êµì§‘í•©, |ëŠ” í•©ì§‘í•©ì´ ëœë‹¤.

null/undefinedë¥¼ ì œì™¸í•œ ì›ì‹œ ìë£Œí˜•ê³¼ ë¹„ì–´ ìˆì§€ ì•Šì€ ê°ì²´ë¥¼ & ì—°ì‚°í•  ë•Œ neverê°€ ë˜ì§€ ì•ŠëŠ”ë‹¤.

# 2.12 íƒ€ì…ë„ ìƒì†ì´ ê°€ëŠ¥í•˜ë‹¤.

extends ì˜ˆì•½ì–´ë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ì¡´ íƒ€ì…ì„ ìƒì†í•  ìˆ˜ ìˆë‹¤. ì¤‘ë³µìœ¼ë¡œ ì„ ì–¸í•˜ëŠ” ê²ƒì„ ë§‰ì„ ìˆ˜ ìˆë‹¤.
íƒ€ì… ë³„ì¹­ë„ êµì§‘í•©ì„ ëœ»í•˜ëŠ” `&`ë¥¼ ì‚¬ìš©í•˜ì—¬ ìƒì†ì´ ê°€ëŠ¥í•˜ë‹¤.

```ts
type Animal = {
  name: string;
};

type Dog = Animal & {
  bark(): void;
};

type Cat = Animal & {
  meow(): void;
};

type Name = Cat["name"];
```

íƒ€ì… ë³„ì¹­ì´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ìƒì†í•  ìˆ˜ ìˆê³ , ì¸í„°í˜ì´ìŠ¤ê°€ íƒ€ì… ë³„ì¹­ì„ ìƒì†í•  ìˆ˜ë„ ìˆë‹¤.

```ts
interface Animal {
  name: string;
}

type Cat = Animal & {
  meow(): void;
};
```

```ts
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}
```

í•œ ë²ˆì— ì—¬ëŸ¬ íƒ€ì…ì„ ìƒì†í•  ìˆ˜ ìˆê³ , ìƒì†í•  ë•Œ ë¶€ëª¨ ì†ì„±ì˜ íƒ€ì…ì„ ë³€ê²½í•  ìˆ˜ ìˆë‹¤. ë‹¨, ì™„ì „íˆ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ë³€ê²½í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.

```tsx
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}

interface Cat extends Animal {
  meow(): void;
}

interface DogCat extends Dog, Cat {}
// âœ… ë” ì¢ì€ íƒ€ì…ìœ¼ë¡œ ìƒì†í•  ìˆ˜ ìˆë‹¤.
interface DogCat1 extends Dog, Cat {
  name: "ê°•ì•„ì§€";
}
// âŒ ì™„ì „íˆ ë‹¤ë¥¸ íƒ€ì…ìœ¼ë¡œ ë³€ê²½í•˜ë©´ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
interface DogCat2 extends Dog, Cat {
  name: 123;
}
```

# 2.13 ê°ì²´ ê°„ì— ëŒ€ì…í•  ìˆ˜ ìˆëŠ”ì§€ í™•ì¸í•˜ëŠ” ë²•ì„ ë°°ìš°ì.

> [!tip]
> ì¢ì€ íƒ€ì…ê³¼ ë„“ì€ íƒ€ì…ì— ëŒ€í•´ ì´í•´ë¥¼ í•  ê²ƒ.

â­•ï¸ ì¢ì€ íƒ€ì… => ë„“ì€ íƒ€ì…
âŒ ë„“ì€ íƒ€ì… => ì¢ì€ íƒ€ì…

```ts
interface A {
  name: string;
}

interface B {
  name: string;
  age: number;
}
```

Aíƒ€ì…ì´ Bíƒ€ì…ë³´ë‹¤ ë” ë„“ì€ íƒ€ì…ì…ë‹ˆë‹¤. Bê°€ ì½”ë“œì˜ ì–‘ê³¼ ì¤„ ìˆ˜ê°€ ë” ë§ì•„ì„œ Bê°€ ë„“ë‹¤ê³  ìƒê°í•  ìˆ˜ ìˆì§€ë§Œ ì½”ë“œì˜ ì–‘ê³¼ ì¤„ ìˆ˜ê°€ ë” ë§ì€ ì´ìœ ëŠ” ê·¸ë§Œí¼ ë” êµ¬ì²´ì ìœ¼ë¡œ ì ì—ˆê¸° ë•Œë¬¸ì´ë‹¤. êµ¬ì²´ì ì´ë¼ëŠ” ê²ƒì€ ì¡°ê±´ì„ ë§Œì¡±í•˜ê¸° ë” í˜ë“¤ë‹¤ëŠ” ëœ»ì´ê³ , ë” ì¢ì€ íƒ€ì…ì´ë¼ëŠ” ê²ƒì´ë‹¤.

íŠœí”Œì€ ë°°ì—´ë³´ë‹¤ ì¢ì€ íƒ€ì…ì´ë‹¤.
string[]ì´ readonly string[]ë³´ë‹¤ ë” ì¢ì€ íƒ€ì…ì´ë‹¤.
ë‘ ê°ì²´ê°€ ìˆê³  ì†ì„±ì´ ë™ì¼í•  ë•Œ, ì†ì„±ì´ ì˜µì…”ë„ì¸ ê°ì²´ê°€ ì˜µì…”ë„ì´ì§€ ì•Šì€ ê°ì²´ë³´ë‹¤ ë” ë„“ì€ íƒ€ì…ì´ë‹¤.
ì˜µì…”ë„ì´ë€ ê¸°ì¡´ íƒ€ì…ì— undefinedê°€ ìœ ë‹ˆì–¸ëœ ê²ƒê³¼ ê°™ë‹¤. `ê¸°ì¡´ íƒ€ì… | undefined`ê°€ ê¸°ì¡´ íƒ€ì…ë³´ë‹¤ ë„“ì€ íƒ€ì…ì´ë¯€ë¡œ ì˜µì…”ë„ ê°ì²´ê°€ ë” ë„“ì€ íƒ€ì…ì´ë‹¤.

## 2.13.1 êµ¬ì¡°ì  íƒ€ì´í•‘

íƒ€ì…ìŠ¤í¬ë¦½íŠ¸ì—ì„œëŠ” ëª¨ë“  ì†ì„±ì´ ë™ì¼í•˜ë©´ ê°ì²´ íƒ€ì…ì˜ ì´ë¦„ì´ ë‹¤ë¥´ë”ë¼ë„ ë™ì¼í•œ íƒ€ì…ìœ¼ë¡œ ì·¨ê¸‰í•œë‹¤. ì´ê²ƒì„ **êµ¬ì¡°ì  íƒ€ì´í•‘(structural typing)** ì´ë¼ í•œë‹¤.

êµ¬ì¡°ì ìœ¼ë¡œ ë™ì¼í•˜ì§€ ì•Šê²Œ ë§Œë“¤ë ¤ë©´ **ë¸Œëœë“œ(brand) ì†ì„±**ì„ ì¶”ê°€í•˜ë©´ ëœë‹¤. ì•„ë˜ì˜ ì˜ˆì‹œì²˜ëŸ¼ ê¼­ `__type` ì´ ì•„ë‹ˆì–´ë„ ë˜ë©° ë‹¤ë¥¸ ì†ì„±ê³¼ ê²¹ì¹˜ì§€ ì•ŠëŠ” ì´ë¦„ì´ë©´ ëœë‹¤. ë¸Œëœë“œ ì†ì„±ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ë¸Œëœë”©(branding) í•œë‹¤ê³  í‘œí˜„í•œë‹¤.

```tsx
interface Money {
  __type: "money";
  amount: number;
  unit: string;
}

interface Liter {
  __type: "liter";
  amount: number;
  unit: string;
}
```

# 2.14 ì œë„¤ë¦­ìœ¼ë¡œ íƒ€ì…ì„ í•¨ìˆ˜ì²˜ëŸ¼ ì‚¬ìš©í•˜ì.

> [!tip]
> ì œë„¤ë¦­ì„ í•¨ìˆ˜ë¼ê³  ìƒê°í•˜ì. í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ì— í˜¸ì¶œí•  ë•Œ ë„£ì€ ì¸ìˆ˜ê°€ ëŒ€ì‘ë˜ëŠ” ê²ƒì²˜ëŸ¼!

```tsx
interface Joo {
  type: "humam";
  race: "yellow";
  name: "Joo";
  age: 37;
}

interface Kiu {
  type: "humam";
  race: "yellow";
  name: "Kiu";
  age: 20;
}
```

typeê³¼ race ì†ì„±ì˜ íƒ€ì…ì€ ë™ì¼í•œë°, nameê³¼ age ì†ì„±ì˜ íƒ€ì…ì€ ë‹¤ë¥´ë‹¤. ì œë„¤ë¦­(Generic)ì„ ì‚¬ìš©í•˜ì—¬ ì¤‘ë³µì„ ì œê±°í•  ìˆ˜ ìˆë‹¤.

```ts
interface Person<N, A> {
  type: "humam";
  race: "yellow";
  name: N;
  age: A;
}

interface Joo extends Person<"Joo", 37> {}
interface Kiu extends Person<"Kiu", 20> {}
```

ì œë„¤ë¦­ í‘œê¸°ëŠ” `<>`ë¡œ í•˜ë©° ì¸í„°í˜ì´ìŠ¤ ì´ë¦„ ë°”ë¡œ ë’¤ì— ìœ„ì¹˜í•œë‹¤. <>ì•ˆì— íƒ€ì… ë§¤ê°œë³€ìˆ˜(Type Parameter)ë¥¼ ë„£ìœ¼ë©´ ëœë‹¤. ì„ ì–¸í•œ ì œë„¤ë¦­ì„ ì‚¬ìš©í•  ë•ŒëŠ” ë§¤ê°œë³€ìˆ˜ì— ëŒ€ì‘í•˜ëŠ” ì‹¤ì œ íƒ€ì… ì¸ìˆ˜(Type Argument)ë¥¼ ë„£ìœ¼ë©´ ëœë‹¤.

â—ï¸ ì œë„¤ë¦­ì€ ë‹¤ìŒê³¼ ê°™ì€ ìœ„ì¹˜ë¥¼ ì‚¬ìš©í•´ì•¼ í•œë‹¤. (ì•”ê¸°í•  ê²ƒ)

- `interface ì´ë¦„<íƒ€ì… ë§¤ê°œë³€ìˆ˜ë“¤> {...}`
- `type ì´ë¦„<íƒ€ì… ë§¤ê°œë³€ìˆ˜ë“¤> = {...}`
- `class ì´ë¦„<íƒ€ì… ë§¤ê°œë³€ìˆ˜ë“¤> {...}`
- `function ì´ë¦„<íƒ€ì… ë§¤ê°œë³„ìˆ˜ë“¤>(...) {...}`
- `const í•¨ìˆ˜ì´ë¦„ = <íƒ€ì… ë§¤ê°œë³€ìˆ˜ë“¤>(...) => {...}`

ì œë„¤ë¦­ì— ì§ì ‘ íƒ€ì…ì„ ë„£ì§€ ì•Šì•„ë„ ì¶”ë¡ ì„ í†µí•´ íƒ€ì…ì„ ì•Œ ìˆ˜ ìˆìœ¼ë©°, ì‹¤ì œë¡œ ì§ì ‘ ë„£ì§€ ì•Šì€ ê²½ìš°ê°€ ë” ë§ë‹¤.

```tsx
function values<const T>(initial: T[]) {
  return {
    hasValue(value: T) {
      return initial.includes(value);
    },
  };
}

const saveValues = values(["a", "b", "c"]);
saveValues.hasValue("x");
```

> [!question]
> ì—¬ê¸°ì„œ ì´ì•¼ê¸°í•˜ëŠ” ìƒìˆ˜ íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” ë¬´ì—‡ì¼ê¹Œ?
> ìœ ë‹ˆì–¸ìœ¼ë¡œ ì¶”ë¡ í•œë‹¤ëŠ” ê±´ ë­ì§€??

## 2.14.1 ì œë„¤ë¦­ì— ì œì•½ ê±¸ê¸°

íƒ€ì… ë§¤ê°œë³€ìˆ˜ì— ì œì•½(constraint)ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. íƒ€ì… ë§¤ê°œë³€ìˆ˜ Aì˜ íƒ€ì…ì€ ìˆ«ì íƒ€ì…ì´ì–´ì•¼ í•œë‹¤ëŠ” ëœ»ì´ë‹¤.
ì œì•½ì´ ê±¸ë¦¬ë©´ ì œì•½ì— ì–´ê¸‹ë‚˜ëŠ” íƒ€ì…ì€ ì…ë ¥í•  ìˆ˜ ì—†ì§€ë§Œ ì œì•½ë³´ë‹¤ ë” êµ¬ì²´ì ì¸ íƒ€ì…ì€ ì…ë ¥í•  ìˆ˜ ìˆë‹¤.

```ts
interface Example<A extends number, B = string> {
  // B = íƒ€ì… ë°©ì‹ìœ¼ë¡œ ê¸°ë³¸ê°’ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤.
  a: A;
  b: B;
}

type UseCase1 = Example<string, boolean>;
// Type 'string' does not satisfy the constraint 'number'.
// number íƒ€ì…ìœ¼ë¡œ ì œì•½ì„ í–ˆìœ¼ë¯€ë¡œ ì œì•½ì— ì–´ê¸‹ë‚˜ëŠ” íƒ€ì…ì„ ì…ë ¥í•˜ë©´ ì—ëŸ¬ê°€ ë‚œë‹¤.

type UseCase2 = Example<1, boolean>;
// number íƒ€ì…ì˜ êµ¬ì²´ì ì¸ íƒ€ì…ì¸ ë¦¬í„°ëŸ´ 1ì€ ì…ë ¥í•  ìˆ˜ ìˆë‹¤.
type UseCase3 = Example<number>;
// ê¸°ë³¸ê°’ì„ ì„¤ì •í•˜ì˜€ê¸° ë•Œë¬¸ì— Bë¥¼ ì…ë ¥í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.

const useCase3: UseCase3 = { a: 1, b: false };
// Type 'boolean' is not assignable to type 'string'.
// The expected type comes from property 'b' which is declared here on type
// íƒ€ì… ë³„ì¹­ì„ ì„ ì–¸í•  ë•Œ ê¸°ë³¸ê°’ì¸ string íƒ€ì…ìœ¼ë¡œ ì„¤ì •í–ˆìœ¼ë¯€ë¡œ boolean íƒ€ì…ì„ ë„£ì–´ì„œ ì—ëŸ¬ê°€ ë‚¬ë‹¤.
```

í•˜ë‚˜ì˜ íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ ë‹¤ë¥¸ íƒ€ì… ë§¤ê°œë³€ìˆ˜ì˜ ì œì•½ì´ ë  ìˆ˜ ìˆë‹¤.

```ts
interface Example<A, B extends A> {
  // B íƒ€ì… ë§¤ê°œë³€ìˆ˜ëŠ” A íƒ€ì…ì´ì–´ì•¼ í•œë‹¤.
  a: A;
  b: B;
}

type UseCase1 = Example<string, number>;
// Type 'number' does not satisfy the constraint 'string'.
type UseCase2 = Example<string, "123">;
type UseCase3 = Example<number, 123>;
```

ìì£¼ì“°ëŠ” ì œì•½ë“¤ì´ ì¡´ì¬í•œë‹¤. ê°ê° íƒ€ì… ë§¤ê°œë³€ìˆ˜ê°€ ê°ì²´, ë°°ì—´, í•¨ìˆ˜, ìƒì„±ì, ì†ì„±ì˜ í‚¤ì—¬ì•¼ í•œë‹¤ëŠ” ì œì•½ì„ ë‚˜íƒ€ë‚¸ë‹¤.

```ts
<T extends object> // ëª¨ë“  ê°ì²´
<T extends any[]> // ëª¨ë“  ë°°ì—´
<T extends (...args: any) => any> // ëª¨ë“  í•¨ìˆ˜
<T extends abstract new (...args: any) => any> // ìƒì„±ì íƒ€ì…
<T extends keyof any> // string | number | symbol
```

# 2.15 ì¡°ê±´ë¬¸ê³¼ ë¹„ìŠ·í•œ ì»¨ë””ì…”ë„ íƒ€ì…ì´ ìˆë‹¤.

ì¡°ê±´ì— ë”°ë¼ ë‹¤ë¥¸ íƒ€ì…ì´ ë˜ëŠ” ì»¨ë””ì…”ë„ íƒ€ì…(Conditional Type)ì´ ìˆë‹¤.

íŠ¹ì • íƒ€ì… extends ë‹¤ë¥¸ íƒ€ì… ? ì°¸ì¼ ë•Œ íƒ€ì… : ê±°ì§“ì¼ ë•Œ íƒ€ì…

íŠ¹ì • íƒ€ì…ì´ ë‹¤ë¥¸ íƒ€ì…ì˜ ë¶€ë¶„ì§‘í•©ì¼ ë•Œ ì°¸ì´ ëœë‹¤. íŠ¹ì • íƒ€ì…(ì¢ì€ íƒ€ì…)ì´ ë‹¤ë¥¸ íƒ€ì…(ë„“ì€ íƒ€ì…)ì— ëŒ€ì… ê°€ëŠ¥í•  ë•Œ ì°¸ì´ ëœë‹¤. 

```ts
type A1 = string;
type B1 = A1 extends string ? number : boolean;
// type B1 = number

type A2 = number;
type B2 = A1 extends string ? number : boolean;
// type B2 = boolean
```

íƒ€ì… ê²€ì‚¬ë¥¼ ìœ„í•´ì„œë„ ë§ì´ ì‚¬ìš©í•œë‹¤.
ë§¤í•‘ëœ ê°ì²´ íƒ€ì…ì—ì„œ í‚¤ê°€ neverì´ë©´ í•´ë‹¹ ì†ì„±ì€ ì œê±°ê°€ ëœë‹¤.

```ts
type OmitByType<O, T> = {
    [K in keyof O as O[K] extends T ? never : K]: O[K];
};

type Result = OmitByType<{
    name:string;
    age: number;
    married: boolean;
    rich: boolean;
}, boolean>
```

ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ ì‚¼í•­ì—°ì‚°ìì²˜ëŸ¼ ì¤‘ì²©í•˜ì—¬ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤. 

## 2.15.1 ì»¨ë””ì…”ë„ íƒ€ì… ë¶„ë°°ë²•ì¹™

ì œë„¤ë¦­ê³¼ neverì˜ ì¡°í•©ì„ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.  ì»¨ë””ì…”ë„ íƒ€ì…ì˜ ê²€ì‚¬í•˜ë ¤ëŠ” íƒ€ì…ì´ **ì œë„¤ë¦­ì´ë©´ì„œ ìœ ë‹ˆì–¸ì´ë©´** ë¶„ë°°ë²•ì¹™ì´ ì‹¤í–‰ëœë‹¤.
```ts
type Start = string | number;
// type Result = Start extends string ? Start[] : never;
// Startê°€ ë” ë„“ê¸° ë•Œë¬¸ì— type Result = never;
type Result<Key> = Key extends string ? Key[] : never;

let n:  Result<Start> = ['hi'];

// Result<string> | Result<number> // ë¶„ë°°ë²•ì¹™ 
// Key extends string | number ? Key[] : never
```

ë‹¨, booleanì— ë¶„ë°°ë²•ì¹™ì„ ì ìš©í•  ë•ŒëŠ” ì¡°ì‹¬í•´ì•¼ í•œë‹¤.

```ts
type Start = string | number | boolean;
type Result<Key> = Key extends string | boolean ? Key[] : never;

let n:  Result<Start> = ['hi'];
// let n: string[] | false[] | true[]
n = [true]
```

ë°°ì—´ë¡œ ì œë„¤ë¦­ì„ ê°ì‹¸ë©´ ë¶„ë°°ë²•ì¹™ì´ ì¼ì–´ë‚˜ì§€ ì•ŠëŠ”ë‹¤.

```ts
type IsString<T> = [T] extends [string] ? true : false;
type Result = IsString<'hi' | 3>;

// ['hi' | 3]ì´ [string]ì„ extendsí•˜ëŠ”ì§€ ê²€ì‚¬í•œë‹¤.
// ['hi' | 3]ì´ ì¢ì€ íƒ€ì…ì´ [string]ë³´ë‹¤ ì¢ì€ íƒ€ì…ì´ ì•„ë‹ˆë¯€ë¡œ falseê°€ ëœë‹¤.
```

neverë„ ë¶„ë°°ë²•ì¹™ì˜ ëŒ€ìƒì´ ëœë‹¤.

```ts
type R<T> = T extends string ? true : false;
type RR = R<never>;

// type RR = R<never>;
```

ì œë„¤ë¦­ê³¼ neverê°€ ë§Œë‚˜ë©´ neverê°€ ëœë‹¤. 

```ts
type IsNever<T> = [T] extends [never] ? true : false;
type T = IsNever<never>;
// type T = true;
type F = IsNever<'never'>;
// type F = false;
```

# 2.16 í•¨ìˆ˜ì™€ ë©”ì„œë“œë¥¼ íƒ€ì´í•‘í•˜ì

ë‚˜ë¨¸ì§€ ë§¤ê°œë³€ìˆ˜ ë¬¸ë²•ì€ ë°°ì—´ì˜ ì „ê°œ ë¬¸ë²•ê³¼ ë‹¬ë¦¬ ë§¤ê°œë³€ìˆ˜ì˜ ë§ˆì§€ë§‰ ìë¦¬ì—ë§Œ ìœ„ì¹˜í•´ì•¼ í•œë‹¤.
```ts
function example1(a: string, ...b : number[]) {}
function example2(...a: string[], b : number) {}
// A rest parameter must be last in a parameter list.

function example3(...args: [number, string, boolean]) {}
function example4(...args: [a: number, b: string, c: boolean]) {}
```

# 2.17 ê°™ì€ ì´ë¦„ì˜ í•¨ìˆ˜ë¥¼ ì—¬ëŸ¬ ë²ˆ ì„ ì–¸í•  ìˆ˜ ìˆë‹¤

í˜¸ì¶œí•  ìˆ˜ ìˆëŠ” í•¨ìˆ˜ì˜ íƒ€ì…ì„ ë¯¸ë¦¬ ì—¬ëŸ¬ê°œ íƒ€ì´í•‘í•´ë‘ëŠ” ê¸°ë²•ì„ ì˜¤ë²„ë¡œë”©(overloading)ì´ë¼ê³  í•œë‹¤.

```ts
function add(x:number, y: number): number
function add(x:string, y: string): string
function add(x: any, y: any) {
    return x + y
}

add(1, 2);
add('1', '2');
```

ì´ ìƒíƒœì—ì„œ `add('1', 2)` , `add(1, '2')`ì„ í•˜ë©´ ì˜¤ë²„ë¡œë”©ì„ í•˜ì§€ ì•Šì•„ì„œ ì—ëŸ¬ê°€ ë°œìƒí•œë‹¤.
ì˜¤ë²„ë¡œë”© ìˆœì„œë„ íƒ€ì… ì¶”ë¡ ì— ì˜í–¥ì„ ë¯¸ì¹œë‹¤. ìë°”ìŠ¤í¬ë¦½íŠ¸ì´ ifë¬¸ ì²˜ëŸ¼ ì œì¼ ë¨¼ì € ì„ ì–¸ëœ ìˆœì„œëŒ€ë¡œ ì˜¤ë²„ë¡œë”©í•œë‹¤ê³  ìƒê°í•˜ë©´ ëœë‹¤.

ì¸í„°í˜ì´ìŠ¤ì™€ íƒ€ì… ë³„í•‘ìœ¼ë¡œ ì˜¤ë²„ë¡œë”©ì„ í‘œí˜„í•  ìˆ˜ ìˆë‹¤.
```ts
interface Add {
    (x: number, y: number) : number;
    (x: string, y: string) : string;
}

type Add1 = (x: number, y: number) => number;
type Add2 = (x: string, y: string) => string;

type TypeAdd = Add1 & Add2;
```

ì• ì´ˆì— ì˜¤ë²„ë¡œë”©í•  í•„ìš”ê°€ ì—†ì€ë° ì˜¤ë²„ë¡œë”©í–ˆë‹¤ê°€ ë¬¸ì œê°€ ë  ìˆ˜ ìˆë‹¤.
ìœ ë‹ˆì–¸ì´ë‚˜ ì˜µì…”ë„ ë§¤ê°œë³€ìˆ˜ë¥¼ í™œìš©í•  ìˆ˜ ìˆëŠ” ê²½ìš°ëŠ” ì˜¤ë²„ë¡œë”©ì„ ì“°ì§€ ì•ŠëŠ” ê²Œ ì¢‹ë‹¤.

# 2.18 ì½œë°± í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ëŠ” ìƒëµ ê°€ëŠ¥í•˜ë‹¤.

```ts
function example(callback: (error: Error, result: string) => void) {}

example((e,r) => {});
// e, r ë§¤ê°œë³€ìˆ˜ì˜ íƒ€ì…ì„ í‘œê¸°í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.
// example ì„ ì–¸ë¶€ì—ì„œ ì´ë¯¸ íƒ€ì…ì„ í‘œê¸°í–ˆê¸° ë•Œë¬¸ì— íƒ€ì… ì¶”ë¡ ì„ í•œë‹¤. 
// ë¬¸ë§¥ì  ì¶”ë¡ (Contextual Typing)

example(() => {});
// ì½œë°± í•¨ìˆ˜ì˜ ë§¤ê°œë³€ìˆ˜ëŠ” í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•  ë•Œ ì‚¬ìš©í•˜ì§€ ì•Šì•„ë„ ëœë‹¤.
// example ì„ ì–¸ë¶€ì—ì„œ ì˜µì…”ë„ë¡œ ë§Œë“¤ì–´ë²„ë¦¬ë©´ íƒ€ì… | undefined ê°€ ë˜ì–´ë²„ë¦¬ë¯€ë¡œ ì‚¬ìš©í•˜ì§€ ë§ì.

example(() => true);
// ì½œë°± í•¨ìˆ˜ì˜ ë°˜í™˜ê°’ì´ voidì¼ ë•ŒëŠ” ì–´ë– í•œ ë°˜í™˜ê°’ì´ ì™€ë„ ìƒê´€ì—†ë‹¤.
```

