# 2.9 μΈν„°νμ΄μ¤λ΅ κ°μ²΄λ¥Ό νƒ€μ΄ν•‘ν•μ.

μΈν„°νμ΄μ¤(interface) μ„ μ–Έμ„ μ‚¬μ©ν•λ” κ²ƒ. μ΄λ¦„μ€ νƒ€μ… λ³„μΉ­κ³Ό λ§μ°¬κ°€μ§€λ΅ λ€λ¬Έμλ΅ μ‹μ‘ν•λ” λ‹¨μ–΄λ¥Ό λ§λ“λ” κ²ƒμ΄ κ΄€λ΅€.
μΈν„°νμ΄μ¤λ¥Ό μ…λ ¥ν•  λ• μ½¤λ§λ‚ μ„Έλ―Έμ½λ΅ , μ¤„λ°”κΏμΌλ΅ κµ¬λ¶„ν•  μ μλ”λ° ν•κ°€μ§€ λ°©μ‹μΌλ΅ μ‚¬μ©ν•  κ²ƒμ€ κ¶μ¥ν•λ‹¤.

```typescript
interface Arr {
  length: number;
  [key: number]: string;
}

const arr: Arr = ["3", "5", "7"];

arr.slice();
// Error: Property 'slice' does not exist on type 'Arr'.
```

μΈλ±μ¤ μ‹κ·Έλ‹μ²(Index Signature) : μ΄ κ°μ²΄μ lengthλ¥Ό μ μ™Έν• μ†μ„± ν‚¤κ°€ μ „λ¶€ numberλΌλ” μλ―Έμ΄λ‹¤. Arr μΈν„°νμ΄μ¤λ” λ°°μ—΄μ„ μ •ν™•ν•κ² κµ¬ν„ν• κ²ƒμ΄ μ•„λ‹λ―€λ΅ λ°°μ—΄ λ‚΄μ¥ λ©”μ„λ“λ¥Ό μ‚¬μ©ν•  μ μ—†λ‹¤.
λ‚΄μ¥ λ©”μ„λ“λ¥Ό μ‚¬μ©ν•  μ μλ” λ°©λ²•μ€ 2.10μ—μ„ μ•μ•„λ³΄μ.

## 2.9.1 μΈν„°νμ΄μ¤ μ„ μ–Έ λ³‘ν•©

κ°™μ€ μ΄λ¦„μΌλ΅ μ—¬λ¬ μΈν„°νμ΄μ¤λ¥Ό μ„ μ–Έν•  μ μλ‹¤. λ€μ‹  ν•λ‚λ΅ ν•©μ³μ§„λ‹¤.

## 2.9.2 λ„¤μ„μ¤νμ΄μ¤

κ°™μ€ μ΄λ¦„μ„ μ‚¬μ©ν•λ©΄ μΈν„°νμ΄μ¤κ°€ λ³‘ν•©λμ–΄ μ›ν•μ§€ μ•λ” κ²°κ³Όλ¥Ό λ‚³κ² λλ‹¤. λ„¤μ„μ¤νμ΄μ¤(namespace)λ¥Ό μ‚¬μ©ν•λ©΄ κ°μ²΄μ²λΌ μ ‘κ·Όν•μ—¬ μ‚¬μ©κ°€λ¥ν•λ‹¤. λ‹¨, λ„¤μ„μ¤νμ΄μ¤ μ•μ— κ°μ²΄λ¥Ό exportλ¥Ό ν•΄μ•Ό ν•λ‹¤.

λ„¤μ„μ¤νμ΄μ¤ λ‚΄λ¶€μ— μ‹¤μ  κ°’μ„ μ„ μ–Έν•μ—¬ μ‚¬μ©ν•  μ μλ‹¤. `[]`λ¥Ό μ‚¬μ©ν•΄μ„ μ ‘κ·Όν•  μ μμΌλ‚ νƒ€μ…μ΄λ‚ μΈν„°νμ΄μ¤λ” `[]`λ¥Ό μ‚¬μ©ν•΄μ„ μ ‘κ·Όν•  μ μ—†λ‹¤.

```typescript
namespace Example {
  export interface Inner {
    test: string;
  }
  export type test2 = number;
  export const a = "real";
}

const ex1: Example.Inner = {
  test: "hi",
};
const ex2: Example.test2 = 3;
const ex3 = Example.a;
const ex4 = Example["a"];
// β
const ex5: Example["test2"] = 5;
// Cannot use namespace 'Example' as a type.
```

λ„¤μ„μ¤νμ΄μ¤λ„ μ΄λ¦„μ΄ κ²ΉμΉλ” κ²½μ° λ³‘ν•©μ΄ λλ‹¤.
λ‚΄λ¶€μ— κ°™μ€ μ΄λ¦„μ μΈν„°νμ΄μ¤κ°€ μμΌλ©΄ ν•©μ³μ§€κ³ , λ‚΄λ¶€μ— κ°™μ€ μ΄λ¦„μ νƒ€μ…μ΄ μλ‹¤λ©΄ μ—λ¬κ°€ λ‚λ‹¤.

# 2.10 κ°μ²΄μ μ†μ„±κ³Ό λ©”μ„λ“μ— μ μ©λλ” νΉμ§•μ„ μ•μ

κ°μ²΄μ μ†μ„±μ— μ μ©λλ” νΉμ§•μ€ μΈν„°νμ΄μ¤λ΅ μ„ μ–Έν–λ“ , νƒ€μ… λ³„μΉ­μΌλ΅ μ„ μ–Έν–λ“  μƒκ΄€μ—†μ΄ κ³µν†µμ μΌλ΅ μ μ©λλ‹¤.

μµμ…”λ„(optional)μ΄λ‚ readonly μμ‹μ–΄κ°€ κ°€λ¥ν•λ‹¤.

```typescript
// μ „κ° λ¬Έλ²•κ³Ό λ‚λ¨Έμ§€ μ†μ„±
const {
  prop: { nested, ...rest },
} = { prop: { nested: "hi", a: 1, b: true } };
const spread = { a: "hi", b: 123 };
const obj = { ...spread };

// κµ¬μ΅°λ¶„ν•΄ ν• λ‹Ήν•  λ• λ§μ΄ μ‹¤μν•λ” κ²ƒ
// β μλ»λ μμ‹
const {
  prop: { nested: string },
} = {
  prop: { nested: "hi" },
};
// const string: string

// π‘ μ¬λ°”λ¥Έ μμ‹
const {
  prop: { nested },
}: { prop: { nested: string } } = {
  prop: { nested: "hi" },
};
```

κΈ°λ³Έμ μΌλ΅ κ°μ²΄λ¥Ό νƒ€μ΄ν•‘ν•  λ• (κ°μ²΄ λ¦¬ν„°λ΄ λ€μ…) μ„ μ–Έν•μ§€ μ•μ€ μ†μ„±μ— λ€ν•΄μ„λ” μ—λ¬κ°€ λ°μƒν•μ§€λ§ λ³€μλ¥Ό λ€μ…ν–μ„ λ•λ” μ—λ¬κ°€ λ°μƒν•μ§€ μ•λ”λ‹¤. κ·Έ μ΄μ λ” κ°μ²΄ λ¦¬ν„°λ΄μ„ λ€μ…ν–μ„ λ• νƒ€μ…μ¤ν¬λ¦½νΈκ°€ μ‰μ—¬ μ†μ„± κ²€μ‚¬(Excess Property Checking)λ¥Ό μ‹¤ν–‰ν•κΈ° λ•λ¬Έμ΄λ‹¤. μ‰μ—¬ μ†μ„± κ²€μ‚¬λ” νƒ€μ… μ„ μ–Έμ—μ„ μ„ μ–Έν•μ§€ μ•μ€ μ†μ„±μ„ μ‚¬μ©ν•  λ• μ—λ¬λ¥Ό ν‘μ‹ν•λ” κ²ƒμ„ μλ―Έν•λ‹¤.

## 2.10.1 μΈλ±μ¤ μ ‘κ·Ό νƒ€μ…

```typescript
type Animal = {
  name: string;
};
// β μλ»λ μμ‹
type N3 = Animal.name;
// type N3 = Animal['name']
```

νΉμ • μ†μ„±μ νƒ€μ…μ„ λ³„λ„ νƒ€μ…μΌλ΅ λ§λ“¤κ³  μ‹¶λ‹¤λ©΄ `κ°μ²΄["μ†μ„±"]` λ°©μ‹μΌλ΅ μ ‘κ·Όν•΄μ•Ό ν•λ‹¤. `κ°μ²΄.μ†μ„±` λ°©μ‹μΌλ΅ μ ‘κ·Όν•  μ μ—†λ‹¤. μ΄λ ‡κ² κ°μ²΄ μ†μ„±μ νƒ€μ…μ— μ ‘κ·Όν•λ” λ°©μ‹μ„ μΈλ±μ¤ μ ‘κ·Ό νƒ€μ…(Indexed Acess Type)μ΄λΌκ³  ν•λ‹¤.

```typescript
const obj = {
  hello: "world",
  name: "zero",
  age: 28,
};
type Keys = keyof typeof obj;
// type Keys = "hello" | "name" | "age"
type Values = (typeof obj)[Keys];
// type Values = string | number
```

keyof μ—°μ‚°μμ™€ μΈλ±μ¤ μ ‘κ·Ό νƒ€μ…μ„ ν™μ©ν•΄ ν‚¤μ νƒ€μ…κ³Ό κ°’μ νƒ€μ…μ„ κµ¬ν•  μ μλ‹¤.

```typescript
interface Examples {
  a(): void; // λ©”μ„λ“(λ§¤κ°λ³€μ): λ°ν™κ°’
  b: () => void; // λ©”μ„λ“: (λ§¤κ°λ³€μ) => λ°ν™κ°’
  c: {
    // λ©”μ„λ“:{ (λ§¤κ°λ³€μ): λ°ν™κ°’ }
    (): void;
  };
}
```

κ°μ²΄μ λ©”μ„λ“λ¥Ό μ„ μ–Έν•  λ•λ” μ„Έκ°€μ§€ λ°©μ‹μΌλ΅ μ‚¬μ©ν•  μ μλ‹¤.

## 2.10.2 λ§¤ν•‘λ κ°μ²΄ νƒ€μ…

κ°μ²΄μ μΌλ¶€ μ†μ„±λ§ νƒ€μ…μ„ μ§€μ •ν•  μ μλ‹¤.

λ§¤ν•‘λ κ°μ²΄ νƒ€μ…(Mapped Object Type) κΈ°λ¥μ„ μ‚¬μ©ν•μ—¬ κΈ°μ΅΄ κ°μ²΄ νƒ€μ…μ„ κΈ°λ°μΌλ΅ μƒλ΅μ΄ κ°μ²΄ νƒ€μ…μ„ λ§λ“¤ μ μλ‹¤. `keyof` μ™€ ν•¨κ» μ‚¬μ©λλ©° κ°μ²΄ νƒ€μ…μ ν‚¤(ν”„λ΅νΌν‹° μ΄λ¦„)λ¥Ό μ¶”μ¶ν•λ”λ° μ‚¬μ©λλ‹¤.

μ½”λ“λ¥Ό λ°λ³µν•μ§€ μ•κ³  μ„ νƒμ μΌλ΅ λ§λ“¤ μ μλ‹¤.

```ts
type Person = {
  name: string;
  age: number;
  location: string;
};

// λ¨λ“  ν”„λ΅νΌν‹°λ¥Ό μ„ νƒμ μΌλ΅ λ§λ“λ” λ§¤ν•‘λ κ°μ²΄ νƒ€μ…
type PartialPerson = {
  [key in keyof Person]?: Person[key];
};

// PartialPerson νƒ€μ… μ‚¬μ©
const partialPerson: PartialPerson = {
  name: "Alice",
  age: 30,
};

// μμ‹μ–΄ readonlyμ™€ ? μ‚¬μ©
type Copy = {
  readonly [key in keyof Person]?: Person[key];
};
/*
	type Copy = {
	    readonly name?: string | undefined;
	    readonly age?: number | undefined;
	    readonly location?: string | undefined;
	}
*/

// μμ‹μ–΄ μ κ±°ν•λ” λ°©λ²•
type Remove = {
  -readonly [key in keyof Copy]-?: Copy[key];
};
/*
	μμ‹μ–΄ `readonly`μ™€ `?` μ•μ— `-`λ¥Ό λ¶™μ—¬μ„ readonlyμ™€ ? μμ‹μ–΄κ°€ μ κ±°λμ—λ‹¤.
	type μμ‹μ–΄μ κ±° = {
	    name: string;
	    age: number;
	    location: string;
	}
*/

// as μμ•½μ–΄λ¥Ό ν†µν•΄ μ†μ„± μ΄λ¦„μ„ λ°”κΏ€μ§€ μ •ν•  μ μλ‹¤.
// Capitalizeλ” νƒ€μ…μ¤ν¬λ¦½νΈμ—μ„ μ κ³µν•λ” νƒ€μ…μΌλ΅ λ¬Έμμ—΄μ μ²« λ²μ§Έ μλ¦¬λ¥Ό λ€λ¬Έμν™”ν•λ‹¤.
// keyκ°€ μ„λ²„μ—μ„λ” λ€λ¬Έμλ΅ λ‚΄λ ¤μ¤κ³  ν”„λ΅ νΈμ—μ„λ” μ†λ¬Έμλ΅ λ‚΄λ ¤μ¬ λ• μ“°λ©΄ μΆ‹μ„ κ²ƒ κ°™λ‹¤.
type CapitalizeCopy = {
  [key in keyof Person as Capitalize<key>]: Person[key];
};
/*
	type CapitalizeCopy = {  
		Name: string;  
		Age: number;  
		Location: string;  
	}
*/
```

# 2.11 νƒ€μ…μ„ μ§‘ν•©μΌλ΅ μƒκ°ν•μ (μ λ‹μ–Έ, μΈν„°μ„Ήμ…)

κµμ§‘ν•©μ„ λ‚νƒ€λ‚΄λ” μ—°μ‚°μλ” `&`μ΄λ‹¤. νƒ€μ…μ„ μ§‘ν•©μΌλ΅ μƒκ°ν•λ©΄ μ „μ²΄μ§‘ν•©μ€ unknown, κ³µμ§‘ν•©μ€ neverλ΅ μƒκ°ν•  μ μλ‹¤. &μ€ κµμ§‘ν•©, |λ” ν•©μ§‘ν•©μ΄ λλ‹¤.

null/undefinedλ¥Ό μ μ™Έν• μ›μ‹ μλ£ν•κ³Ό λΉ„μ–΄ μμ§€ μ•μ€ κ°μ²΄λ¥Ό & μ—°μ‚°ν•  λ• neverκ°€ λμ§€ μ•λ”λ‹¤.

# 2.12 νƒ€μ…λ„ μƒμ†μ΄ κ°€λ¥ν•λ‹¤.

extends μμ•½μ–΄λ¥Ό μ‚¬μ©ν•μ—¬ κΈ°μ΅΄ νƒ€μ…μ„ μƒμ†ν•  μ μλ‹¤. μ¤‘λ³µμΌλ΅ μ„ μ–Έν•λ” κ²ƒμ„ λ§‰μ„ μ μλ‹¤.
νƒ€μ… λ³„μΉ­λ„ κµμ§‘ν•©μ„ λ»ν•λ” `&`λ¥Ό μ‚¬μ©ν•μ—¬ μƒμ†μ΄ κ°€λ¥ν•λ‹¤.

```ts
type Animal = {
  name: string;
};

type Dog = Animal & {
  bark(): void;
};

type Cat = Animal & {
  meow(): void;
};

type Name = Cat["name"];
```

νƒ€μ… λ³„μΉ­μ΄ μΈν„°νμ΄μ¤λ¥Ό μƒμ†ν•  μ μκ³ , μΈν„°νμ΄μ¤κ°€ νƒ€μ… λ³„μΉ­μ„ μƒμ†ν•  μλ„ μλ‹¤.

```ts
interface Animal {
  name: string;
}

type Cat = Animal & {
  meow(): void;
};
```

```ts
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}
```

ν• λ²μ— μ—¬λ¬ νƒ€μ…μ„ μƒμ†ν•  μ μκ³ , μƒμ†ν•  λ• λ¶€λ¨ μ†μ„±μ νƒ€μ…μ„ λ³€κ²½ν•  μ μλ‹¤. λ‹¨, μ™„μ „ν λ‹¤λ¥Έ νƒ€μ…μΌλ΅ λ³€κ²½ν•λ©΄ μ—λ¬κ°€ λ°μƒν•λ‹¤.

```tsx
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}

interface Cat extends Animal {
  meow(): void;
}

interface DogCat extends Dog, Cat {}
// β… λ” μΆμ€ νƒ€μ…μΌλ΅ μƒμ†ν•  μ μλ‹¤.
interface DogCat1 extends Dog, Cat {
  name: "κ°•μ•„μ§€";
}
// β μ™„μ „ν λ‹¤λ¥Έ νƒ€μ…μΌλ΅ λ³€κ²½ν•λ©΄ μ—λ¬κ°€ λ°μƒν•λ‹¤.
interface DogCat2 extends Dog, Cat {
  name: 123;
}
```

# 2.13 κ°μ²΄ κ°„μ— λ€μ…ν•  μ μλ”μ§€ ν™•μΈν•λ” λ²•μ„ λ°°μ°μ.

> [!tip]
> μΆμ€ νƒ€μ…κ³Ό λ„“μ€ νƒ€μ…μ— λ€ν•΄ μ΄ν•΄λ¥Ό ν•  κ²ƒ.

β­•οΈ μΆμ€ νƒ€μ… => λ„“μ€ νƒ€μ…
β λ„“μ€ νƒ€μ… => μΆμ€ νƒ€μ…

```ts
interface A {
  name: string;
}

interface B {
  name: string;
  age: number;
}
```

Aνƒ€μ…μ΄ Bνƒ€μ…λ³΄λ‹¤ λ” λ„“μ€ νƒ€μ…μ…λ‹λ‹¤. Bκ°€ μ½”λ“μ μ–‘κ³Ό μ¤„ μκ°€ λ” λ§μ•„μ„ Bκ°€ λ„“λ‹¤κ³  μƒκ°ν•  μ μμ§€λ§ μ½”λ“μ μ–‘κ³Ό μ¤„ μκ°€ λ” λ§μ€ μ΄μ λ” κ·Έλ§νΌ λ” κµ¬μ²΄μ μΌλ΅ μ μ—κΈ° λ•λ¬Έμ΄λ‹¤. κµ¬μ²΄μ μ΄λΌλ” κ²ƒμ€ μ΅°κ±΄μ„ λ§μ΅±ν•κΈ° λ” νλ“¤λ‹¤λ” λ»μ΄κ³ , λ” μΆμ€ νƒ€μ…μ΄λΌλ” κ²ƒμ΄λ‹¤.

νν”μ€ λ°°μ—΄λ³΄λ‹¤ μΆμ€ νƒ€μ…μ΄λ‹¤.
string[]μ΄ readonly string[]λ³΄λ‹¤ λ” μΆμ€ νƒ€μ…μ΄λ‹¤.
λ‘ κ°μ²΄κ°€ μκ³  μ†μ„±μ΄ λ™μΌν•  λ•, μ†μ„±μ΄ μµμ…”λ„μΈ κ°μ²΄κ°€ μµμ…”λ„μ΄μ§€ μ•μ€ κ°μ²΄λ³΄λ‹¤ λ” λ„“μ€ νƒ€μ…μ΄λ‹¤.
μµμ…”λ„μ΄λ€ κΈ°μ΅΄ νƒ€μ…μ— undefinedκ°€ μ λ‹μ–Έλ κ²ƒκ³Ό κ°™λ‹¤. `κΈ°μ΅΄ νƒ€μ… | undefined`κ°€ κΈ°μ΅΄ νƒ€μ…λ³΄λ‹¤ λ„“μ€ νƒ€μ…μ΄λ―€λ΅ μµμ…”λ„ κ°μ²΄κ°€ λ” λ„“μ€ νƒ€μ…μ΄λ‹¤.

## 2.13.1 κµ¬μ΅°μ  νƒ€μ΄ν•‘

νƒ€μ…μ¤ν¬λ¦½νΈμ—μ„λ” λ¨λ“  μ†μ„±μ΄ λ™μΌν•λ©΄ κ°μ²΄ νƒ€μ…μ μ΄λ¦„μ΄ λ‹¤λ¥΄λ”λΌλ„ λ™μΌν• νƒ€μ…μΌλ΅ μ·¨κΈ‰ν•λ‹¤. μ΄κ²ƒμ„ **κµ¬μ΅°μ  νƒ€μ΄ν•‘(structural typing)** μ΄λΌ ν•λ‹¤.

κµ¬μ΅°μ μΌλ΅ λ™μΌν•μ§€ μ•κ² λ§λ“¤λ ¤λ©΄ **λΈλλ“(brand) μ†μ„±**μ„ μ¶”κ°€ν•λ©΄ λλ‹¤. μ•„λμ μμ‹μ²λΌ κΌ­ `__type` μ΄ μ•„λ‹μ–΄λ„ λλ©° λ‹¤λ¥Έ μ†μ„±κ³Ό κ²ΉμΉμ§€ μ•λ” μ΄λ¦„μ΄λ©΄ λλ‹¤. λΈλλ“ μ†μ„±μ„ μ‚¬μ©ν•λ” κ²ƒμ„ λΈλλ”©(branding) ν•λ‹¤κ³  ν‘ν„ν•λ‹¤.

```tsx
interface Money {
  __type: "money";
  amount: number;
  unit: string;
}

interface Liter {
  __type: "liter";
  amount: number;
  unit: string;
}
```

# 2.14 μ λ„¤λ¦­μΌλ΅ νƒ€μ…μ„ ν•¨μμ²λΌ μ‚¬μ©ν•μ.

> [!tip]
> μ λ„¤λ¦­μ„ ν•¨μλΌκ³  μƒκ°ν•μ. ν•¨μμ λ§¤κ°λ³€μμ— νΈμ¶ν•  λ• λ„£μ€ μΈμκ°€ λ€μ‘λλ” κ²ƒμ²λΌ!

```tsx
interface Joo {
  type: "humam";
  race: "yellow";
  name: "Joo";
  age: 37;
}

interface Kiu {
  type: "humam";
  race: "yellow";
  name: "Kiu";
  age: 20;
}
```

typeκ³Ό race μ†μ„±μ νƒ€μ…μ€ λ™μΌν•λ°, nameκ³Ό age μ†μ„±μ νƒ€μ…μ€ λ‹¤λ¥΄λ‹¤. μ λ„¤λ¦­(Generic)μ„ μ‚¬μ©ν•μ—¬ μ¤‘λ³µμ„ μ κ±°ν•  μ μλ‹¤.

```ts
interface Person<N, A> {
  type: "humam";
  race: "yellow";
  name: N;
  age: A;
}

interface Joo extends Person<"Joo", 37> {}
interface Kiu extends Person<"Kiu", 20> {}
```

μ λ„¤λ¦­ ν‘κΈ°λ” `<>`λ΅ ν•λ©° μΈν„°νμ΄μ¤ μ΄λ¦„ λ°”λ΅ λ’¤μ— μ„μΉν•λ‹¤. <>μ•μ— νƒ€μ… λ§¤κ°λ³€μ(Type Parameter)λ¥Ό λ„£μΌλ©΄ λλ‹¤. μ„ μ–Έν• μ λ„¤λ¦­μ„ μ‚¬μ©ν•  λ•λ” λ§¤κ°λ³€μμ— λ€μ‘ν•λ” μ‹¤μ  νƒ€μ… μΈμ(Type Argument)λ¥Ό λ„£μΌλ©΄ λλ‹¤.

β—οΈ μ λ„¤λ¦­μ€ λ‹¤μκ³Ό κ°™μ€ μ„μΉλ¥Ό μ‚¬μ©ν•΄μ•Ό ν•λ‹¤. (μ•”κΈ°ν•  κ²ƒ)

- `interface μ΄λ¦„<νƒ€μ… λ§¤κ°λ³€μλ“¤> {...}`
- `type μ΄λ¦„<νƒ€μ… λ§¤κ°λ³€μλ“¤> = {...}`
- `class μ΄λ¦„<νƒ€μ… λ§¤κ°λ³€μλ“¤> {...}`
- `function μ΄λ¦„<νƒ€μ… λ§¤κ°λ³„μλ“¤>(...) {...}`
- `const ν•¨μμ΄λ¦„ = <νƒ€μ… λ§¤κ°λ³€μλ“¤>(...) => {...}`

μ λ„¤λ¦­μ— μ§μ ‘ νƒ€μ…μ„ λ„£μ§€ μ•μ•„λ„ μ¶”λ΅ μ„ ν†µν•΄ νƒ€μ…μ„ μ• μ μμΌλ©°, μ‹¤μ λ΅ μ§μ ‘ λ„£μ§€ μ•μ€ κ²½μ°κ°€ λ” λ§λ‹¤.

```tsx
function values<const T>(initial: T[]) {
  return {
    hasValue(value: T) {
      return initial.includes(value);
    },
  };
}

const saveValues = values(["a", "b", "c"]);
saveValues.hasValue("x");
```

> [!question]
> μ—¬κΈ°μ„ μ΄μ•ΌκΈ°ν•λ” μƒμ νƒ€μ… λ§¤κ°λ³€μλ” λ¬΄μ—‡μΌκΉ?
> μ λ‹μ–ΈμΌλ΅ μ¶”λ΅ ν•λ‹¤λ” κ±΄ λ­μ§€??

## 2.14.1 μ λ„¤λ¦­μ— μ μ•½ κ±ΈκΈ°

νƒ€μ… λ§¤κ°λ³€μμ— μ μ•½(constraint)μ„ μ‚¬μ©ν•  μ μλ‹¤. νƒ€μ… λ§¤κ°λ³€μ Aμ νƒ€μ…μ€ μ«μ νƒ€μ…μ΄μ–΄μ•Ό ν•λ‹¤λ” λ»μ΄λ‹¤.
μ μ•½μ΄ κ±Έλ¦¬λ©΄ μ μ•½μ— μ–΄κΈ‹λ‚λ” νƒ€μ…μ€ μ…λ ¥ν•  μ μ—†μ§€λ§ μ μ•½λ³΄λ‹¤ λ” κµ¬μ²΄μ μΈ νƒ€μ…μ€ μ…λ ¥ν•  μ μλ‹¤.

```ts
interface Example<A extends number, B = string> {
  // B = νƒ€μ… λ°©μ‹μΌλ΅ κΈ°λ³Έκ°’μ„ μ„¤μ •ν•  μ μλ‹¤.
  a: A;
  b: B;
}

type UseCase1 = Example<string, boolean>;
// Type 'string' does not satisfy the constraint 'number'.
// number νƒ€μ…μΌλ΅ μ μ•½μ„ ν–μΌλ―€λ΅ μ μ•½μ— μ–΄κΈ‹λ‚λ” νƒ€μ…μ„ μ…λ ¥ν•λ©΄ μ—λ¬κ°€ λ‚λ‹¤.

type UseCase2 = Example<1, boolean>;
// number νƒ€μ…μ κµ¬μ²΄μ μΈ νƒ€μ…μΈ λ¦¬ν„°λ΄ 1μ€ μ…λ ¥ν•  μ μλ‹¤.
type UseCase3 = Example<number>;
// κΈ°λ³Έκ°’μ„ μ„¤μ •ν•μ€κΈ° λ•λ¬Έμ— Bλ¥Ό μ…λ ¥ν•μ§€ μ•μ•„λ„ λλ‹¤.

const useCase3: UseCase3 = { a: 1, b: false };
// Type 'boolean' is not assignable to type 'string'.
// The expected type comes from property 'b' which is declared here on type
// νƒ€μ… λ³„μΉ­μ„ μ„ μ–Έν•  λ• κΈ°λ³Έκ°’μΈ string νƒ€μ…μΌλ΅ μ„¤μ •ν–μΌλ―€λ΅ boolean νƒ€μ…μ„ λ„£μ–΄μ„ μ—λ¬κ°€ λ‚¬λ‹¤.
```

ν•λ‚μ νƒ€μ… λ§¤κ°λ³€μκ°€ λ‹¤λ¥Έ νƒ€μ… λ§¤κ°λ³€μμ μ μ•½μ΄ λ  μ μλ‹¤.

```ts
interface Example<A, B extends A> {
  // B νƒ€μ… λ§¤κ°λ³€μλ” A νƒ€μ…μ΄μ–΄μ•Ό ν•λ‹¤.
  a: A;
  b: B;
}

type UseCase1 = Example<string, number>;
// Type 'number' does not satisfy the constraint 'string'.
type UseCase2 = Example<string, "123">;
type UseCase3 = Example<number, 123>;
```

μμ£Όμ“°λ” μ μ•½λ“¤μ΄ μ΅΄μ¬ν•λ‹¤. κ°κ° νƒ€μ… λ§¤κ°λ³€μκ°€ κ°μ²΄, λ°°μ—΄, ν•¨μ, μƒμ„±μ, μ†μ„±μ ν‚¤μ—¬μ•Ό ν•λ‹¤λ” μ μ•½μ„ λ‚νƒ€λ‚Έλ‹¤.

```ts
<T extends object> // λ¨λ“  κ°μ²΄
<T extends any[]> // λ¨λ“  λ°°μ—΄
<T extends (...args: any) => any> // λ¨λ“  ν•¨μ
<T extends abstract new (...args: any) => any> // μƒμ„±μ νƒ€μ…
<T extends keyof any> // string | number | symbol
```
