# 엘리스 트랙-TypeScript Study

## 교재: 타입 스크립트 교과서(조현영 지음)
### -1주차

### 범위: 2.1 ~ 2.8

#### 2.1 변수, 매개변수, 반환값에 타입을 붙이면 된다.

1. 타입스크립트는 기본적으로 변수와 함수의 매개변수(parameter), 반환값에 타입을 부여한다고 볼 수 있다. 

2. const 키워드로 선언한 변수는 변수에 들어간 값이 해당 변수의 타입이 된다. 이것을 리터럴 타입이라고 부른다.

3. var 또는 let으로 변수를 선언할 경우 이 변수의 값이 변경될 가능성이 있음을 컴파일러에게 알려준다. 하지만 const 키워드로 변수를 선언할 경우  TypeScript 컴파일러에게 이 객체는 절대 변경되지 않음을 알려준다.

#### 2.2 타입 추론을 적극 활용하자.

1. var 또는 let으로 변수를 선언할 경우 TypeScript는 해당 변수의 타입을 추론할 때 데이터의 범주로 표현한다.

2. const 키워드로 선언한 symbol 타입 값을 선언할 경우 변수는 해당 변수명이 타입명이 되서 다른 symbol 값으로 변경할 수 없다. 이는 해당 변수가 고유한 symbol 타입이 되었다는 의미다. 이것을 unique symbol이라고 부른다.

3. unique symbol 타입은 unique symbol 타입의 변수끼리 비교할 수 없지만 일반 symbol 타입과 unique symbol, 일반 symbol 타입끼리는 비교할 수 있다.

4. let 키워드로 선언한 변수가 다른 값을 대입할 수 있는 것을 '**타입 넓히기(Type Widening)**'라고 부른다.

5. 타입스크립트의 에러를 무시하고 싶다면 에러가 나는 코드 윗줄에 '@ts-ignore' 주석을 달면 된다. '@ts-expect-error' 에러는 다음 줄의 코드가 반드시 에러가 나지만 무시한다는 의미를 가진 주석이다. <U>**달리 말하면 에러가 나지 않는 코드면 오류 표현이 나온다는 의미다**</U>.

6. 함수 매개변수의 타입을 명시하려면 매개변수 바로 뒤에 표기한다.

7. 반환값이 있는 함수일 경우 함수의 매개변수 소괄호 뒤에 표기한다.

8. '타입스크립트가 타입을 제대로 추론하면 그대로 쓰고, 틀리게 추론할 때만 올바른 타입을 표기한다.'

9. object 타입은 원시형(string, number, null, undefined, symbol, bigint, boolean) 타입들을 제외한 모든 타입들을 의미한다. object 타입에는 배열도 할당이 가능하다.

10. Object 타입은 JavaScript에 포함된 모든 객체를 포함한다.

11. '{}' 타입은 런타임때는 Object 타입과 비슷하게 인식하지만 컴파일 단계에서 다르게 인식한다. '{}' 타입과 Object 타입은 null과 undefined를 제외한 모든 타입을 의미한다.

#### 2.3 값 자체가 타입인 리터럴 타입이 있다.

1. 리터럴 타입 중 문자열 리터럴 타입은 유니언 타입과 타입 별칭에 자주 쓰인다.

2. TypeScript는 JavaScript의 동적 타입을 포기한 대신 타입 안정성을 선택했다.

3. const로 변수를 선언할 경우 TypeScript는 해당 변수가 가진 값을 타입으로 간주한다. 굳이 let 키워드로 변수를 선언하고 특정 값으로 타입 단언을 할 필요가 없다.

4. 리터럴 타입은 문자열, 숫자형 뿐만 아니라 객체 리터럴, 배열 리터럴, 함수 리터럴 타입도 존재한다.

5. JavaScript의 객체는 const 키워드로 선언한다 하더라도 객체 속성값은 변경 가능하다. 객체의 속성값도 고정시키려면 객체 데이터 뒤에 'as const' 문구를 기재한다. 객체 데이터에 'as const' 문구가 붙으면 해당 데이터에 'readonly' 문구가 생기면서 속성값을 변경할 수 없다.

#### 2.4 배열 말고 튜플도 있다.

1. 배열 타입 변수를 선언하려면 변수명 뒤에 '타입[]' 또는 'Array<타입>'을 입력한다. 여기서 타입은 배열에 들어가는 요소의 타입을 의미한다. 배열 요소에는 지정한 타입만 들어갈 수 있다. 참고로 '<>' 기호는 '제네릭(Generic)'을 의미하며 간단하게 설명하지면 타입을 매개변수처럼 사용하는 것이다.

2. TypeScript에서 배열 타입을 추론할 때 배열 요소들의 타입을 토대로 추론한다. 빈 배열은 'any[]' 타입 또는 'never[]' 타입으로 추론한다.

3. 'Number.prototype.toFixed()' 메서드는 소수점의 위치를 고정시켜 표현하는 방식인 고정소수점을 이용해서 숫자형 값을 표현한다.

4. 튜플(tuple)은 각 요소 자리에 타입이 고정되어 있는 배열 타입을 의미한다. 튜플 타입 변수를 생성하려면 타입 선언을 통해서만 만들 수 있다.

5. 튜플은 길이와 각 요소의 타입이 고정된 배열이지만 push, pop, unshift. shift 메서드를 통해 배열에 요소를 추가하거나 제거할 수 있다. 만약 해당 메서드들의 사용을 막으려면 타입을 선언하는 위치에서 대괄호 앞에 readonly 수식어를 붙여준다.

6. 튜플은 길이가 고정된 타입이지만 전개 연산자(Spread Operator)를 사용하면, 특정 인덱스에 특정 타입이 연달아 나올 수 있다.

7. 타입이 아니라 값에 전개 연산자를 사용해도 TypeScript는 타입 추론을 할 수 있다.

8. 구조분해 할당(Destructing Assignment)에서는 나머지 연산자(Rest Operator)를 통해 타입 추론을 사용할 수 있다.

9. 옵셔널('?') 수식어는 값이 있어도 되고 없어도 되는 변수를 만들어 준다. 튜플 타입을 선언할 때 특정 인덱스에 있는 타입에 옵셔널 수식어를 붙이면 튜플 배열을 만들 때 해당 타입 데이터는 없어도 무방한다. 예를 들면 튜플 타입이 [number, boolean?, string]로 선언되면 [number, string] 또는 [number, boolean, string] 타입이 변수에 적용된다는 의미다. 또한 옵셔널 수식어가 붙은 타입에 해당하는 인덱스에는 undefined 값이 들어갈 수 있다.

#### 2.5 타입으로 쓸 수 있는 것을 구분하자

1. 대부분의 리터럴(문자열, 숫자, 배열, 객체 등) 값은 타입으로 사용할 수 있다.

2. 대부분 변수의 이름은 타입으로 사용할 수 없다.

3. Date, Math, Error, String, Object, Number, Boolean 등과 같은 JavaScript 내장 객체는 타입으로 사용할 수 있다. 다만 String, Object, Number, Boolean, Symbol 같이 원시형 타입과 관련된 원시 래퍼 객체들은 타입으로 사용하는 것을 권장하지 않는다. 변경 가능한 속성들이 포함되어 있기 때문에 예상치 못한 결과가 나올 수 있다. 그리고 해당 객체들은 여러 데이터가 있어서 불필요한 메모리를 사용하게 되고, TypeScript의 타입 추론이 기본 자료형에 기반하여 동작하는데 해당 원시 값을 객체로 다루는 원시 래퍼 객체들은 타입 검사를 할 경우 'object' 타입으로 추론된다.

4. 타입으로 쓸 수 있는 값과 쓸 수 없는 값을 외우기 어렵다면 타입으로 표기해본다. 만약 타입으로 쓸 수 없는 값을 쓴다면 TypeScript가 에러 메시지를 호출할 것이다.

5. 변수 앞에 typeof 연산자를 붙여서 타입처럼 사용할 수 있다.

6. 함수 호출은 타입으로 사용할 수 없다.

7. 클래스 이름은 typeof 연산자 없이 타입으로 사용할 수 있다.

#### 2.6 유니언 타입으로 OR 관계를 표현하자

1. 유니언 타입(Union Type)은 TypeScript에서 처음 등장한 타입으로, 파이프 연산자('|')를 이용해서 원시 타입 또는 리터럴 타입을 집어넣어서 하나의 변수가 여러 타입을 가질 수 있게 만들어 준다.

2. 유니언 타입으로 배열 타입을 설정할 때는 소괄호 범위를 잘 맞춰주는 것이 중요하다.

3. 유니언 타입은 함수의 매개변수나 반환 타입으로 사용할 수 있다.

4. 유니언 타입으로부터 정확한 타입을 찾아내는 것을 **타입 좁히기(Type Narrowing)**라고 부른다.

5. 타입 별칭을 만들 때 파이프 연산자를 타입 앞에도 사용할 수 있다.
(예시: type Union1 = | string | boolean | number | null)

#### 2.7 타입스크립트에만 있는 타입을 배우자

1. any 타입: 타입스크립트의 모든 타입을 수용할 수 있는 자료형. 사용자로부터 받은 데이터 혹은 써드 파티 라이브러리 같은 동적인 컨텐츠로 오는 불특정한 값을 컴파일 검사를 하지 않고 이용하고자 할 때 사용한다. 컴파일 단계에서 타입 검사를 하지 않아서 작업하기에 용이하다.

2. any 타입을 통해서 파생되는 결과물은 any 타입의 값이다. 입력값의 타입과 상관없이 변수의 타입이 any라면 결과값의 자료형은 무조건 any 타입이다.

3. 타입스크립트가 변수를 any 타입으로 추론하지 않는 이상 any 타입 사용은 지양하는 것이 좋다. any 타입으로 추론할 경우 'implicitAny' 에러가 발생한다.

4. 빈 배열을 생성할 경우 해당 데이터가 들어간 변수의 타입은 'any[]'이다.

5. any[]로 타입이 추론된 배열은 push 메서드나 인덱스로 요소를 추가할 때마다 추론하는 타입이 바뀐다. 단, concat 메서드로 요소를 넣으면 오류가 발생한다.

## 참조

- 조현영(2023.08). **타입스크립트 교과서.** 길벗

- [리터럴 타입 좁히기 (Literal Narrowing)](https://typescript-kr.github.io/pages/literal-types.html)

- [5.10 Object 객체](https://poiemaweb.com/js-object)

- [[Typescript] Object vs object vs {}](https://velog.io/@njh7799/typescript-Object-vs-object-vs-)

- [[TS] TypeScript Object 다루기](https://muhly.tistory.com/139)

- [심볼형](https://ko.javascript.info/symbol)

- [[JavaScript] 심볼 (Symbol) 타입 이해하기](https://it-eldorado.tistory.com/149)

- [실수 표현(부동 소수점) 원리 한눈에 이해하기](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%8B%A4%EC%88%98-%ED%91%9C%ED%98%84%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%9B%90%EB%A6%AC-%ED%95%9C%EB%88%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0#%EA%B3%A0%EC%A0%95_%EC%86%8C%EC%88%98%EC%A0%90_%EB%B0%A9%EC%8B%9D)

-[TypeScript Object, object, {} 비교 - 자라자 - 티스토리](https://zaraza.tistory.com/74)

-[Typescript에서 String 와 string의 차이](https://heewon26.tistory.com/375)

=[TypeScript에서 string key로 객체에 접근하기](https://soopdop.github.io/2020/12/01/index-signatures-in-typescript/)