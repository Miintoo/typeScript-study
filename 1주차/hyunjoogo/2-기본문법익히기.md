# 2.1 변수, 매개변수, 반환값에 타입을 붙이면 된다.

- 타입을 붙이는 행위를 타이핑(Typing)이라고 한다.
- 변수, 함수의 매개변수와 반환값에 타이핑을 한다.
- 타입의 종류에는 string, number, boolean, null, undefined, symbol, bigint, object(객체와 배열)이 있다.

# 2.2 타입추론을 적극 활용하자.

- 타입스트립트는 알아서 타입을 추론한다. 단, 매개변수는 타입을 부여해야 한다.

> [!tip]
> 타입스크립트가 타입 추론을 제대로 하면 쓰고, 틀리면 타입을 표기하자.

1. 리터럴 타입 : 타입에 값을 직접 입력한 타입
2. 넓은 범위 타입으로 표기해도 됨

- let으로 선언한 변수는 다른 값을 대입할 수 있기에 타입을 넓게 추론하는데 이러한 현상은 타입넓히기 (Type Widning)이라고 한다.

```typescript
const str1 = "hello";
// const str1 : 'hello'
let str2 = "hello";
// let str2 : string
```

# 2.3 값 자체가 타입인 리터럴 타입이 있다

리터럴 타입은 타입에 값을 직접 입력한 타입이다.
원시 자료형, 객체, 배열, 함수도 가능하다.

```typescript
let str1: "hello" = "hello";
str1 = "world";
// 변경 불가

const obj: { name: "zero" } = { name: "zero" };
const arr: [1, "1"] = [1, "1"];
const func: (a: number, b: number) => number = (a, b) => a + b;
```

# 2.4 배열 말고 튜플도 있다.

배열의 존재하지 않는 index에 접근할 수 있다.

```typescript
const arr3 = [1, 3, 5];
arr3[3].toFixed();
```

이러한 접근을 막기 위해 각 요소 자리에 타입이 고정되어 있는 배열을 의미하는 튜플(tuple)을 사용하라.

```typescript
const tuple: [number, string, boolean] = [1, "1", false];

tuple[3] = "no";
// 에러 발생
```

push, pop, unshift, shift 메서드까지 막고 싶다면 readonly를 사용하라.

```typescript
const tuple: readonly [number, string, boolean] = [1, "1", false];

tuple.push("no");
// 에러 발생
```

> [!tip]
> 배열보다 정교한 타입 검사를 원한다면 튜플을 사용하라.

전개 문법, 나머지 속성 문법으로 타입표시가 가능하다.
값을 전개해도 타입스크립트는 타입 추론을 한다.

```typescript
const strNumBools: [string, number, ...boolean[]] = [
  "1",
  1,
  false,
  true,
  false,
];

const arr1 = ["hi", true];
const arr = [46, ...arr1];
// const arr: (string | number | boolean)[]

const [a, ...rest1] = ["hi", true, false];
// const a: string
// const rest1: [boolean, boolean]
```

옵셔널(optional) 수식어도 가능하다.

```typescript
let tuple: [number, boolean?, string?] = [1, false, "hi"];
// let tuple: [number, (boolean | undefined)?, (string | undefined)?]
```

# 2.5 타입으로 쓸 수 있는 것을 구분하자

내장 객체 타입 중 String, Object, Number, Boolean, Symbol은 사용하지 말자.

함수 선언형은 호출이 아니라면 typeof를 사용하여 타입으로 쓸 수 있다.

```typescript
function add(x:number, y:number) {
  return x + y;
}
const add2 : typeof add = (x:number, y:number) => x + y;
const add3 : add(1, 2) = (x:number, y:number) => x + y;
// 에러발생
```

클래스는 typeof 없이도 사용이 가능하다.

# 2.6 유니언 타입으로 OR 관계를 표현하자

파이프 연산자(|)를 사용한 유니언 타입은 하나의 변수가 여러 타입을 가질 수 있는 가능성을 표시하는 것이다.

```typescript
function returnString(value: number | string) {
  return value.toString();
}
```

# 2.7 타입스크립트에만 있는 타입을 배우자

## 2.7.1. any

any는 타입스크립트에서 지양해야 할 타입이다.

> [!tip]
> any 타입은 타입 검사를 포기한다는 선언과 같다. 타입스크립트가 any로 추론하는 타입이 있다면 타입을 직접 표기해야 한다.

타입스크립트가 명시적으로 any를 반환하는 JSON.parse와 fetch 함수에는 타입을 직접 표기해야 한다.

```typescript
fetch("url")
  .then((response) => {
    return response.json();
  })
  .then((result) => {});
// (parameter) result: any

const result = JSON.parse('{"hello":"json"}');
// const result: any
```

아래와 같이 타입을 표시하자.

```typescript
fetch("url")
  .then<{ data: string }>((response) => {
    return response.json();
  })
  .then((result) => {});
// (parameter) result: {data:string}

const result: { hello: string } = JSON.parse('{"hello":"json"}');
// const result: {hello : string}
```

## 2.7.2. unknown

any 타입과 비슷하지만 타입 표시 후 어떠한 동작도 할 수 없게 된다.

```typescript
const a: unknown = "hello";
a.slice();
// 'a' is of type 'unknown'.
```

try/catch문에서 unknwon을 보게 된다. unknwon이므로 그 뒤에 어떠한 동작도 할 수 없다.
`catch(e : 타입)`처럼 직접 타이핑을 할 수 없으므로 as로 타입을 주장(Type Assertion)을 해야 한다.

```typescript
try {
} catch (e) {
  console.log(e.message);
}
// 'e' is of type 'unknown'.

try {
} catch (e) {
  const error = e as Error;
  console.log(error.message);
}
```

as 같은 것으로 !(non-null assertion) 연산자가 있다. null 뿐만 아니라 undefined도 아님을 주장할 수 있다.

```typescript
function a(param: string | null | undefined) {
  param.slice(3);
}
// 'param' is possibly 'null' or 'undefined'

function a(param: string | null | undefined) {
  param!.slice(3);
}
```

## 2.7.3 void

void는 함수의 반환값을 무시하도록 하는 특수 타입이다. 함수의 반환값이 없는 경우 반환값이 void 타입으로 추론된다.

## 2.7.4 {}, Object

대문자 O이다. null과 undefined를 제외한 모든 값을 의미한다. 대입은 가능하지만 사용할수 없으므로 타이핑하는 의미가 무색하다.

## 2.7.5 never

never 타입에는 어떠한 타입도 대입할 수 없다. 함수 선언문과 함수 표현식일 때 차이가 있다.

> [!tip]
> 함수 선언문은 `function 함수명() {}`으로 선언한 함수이다.
> 함수 표현식은 `const 함수명 = () => {}` 로 표현한 함수이다.

throw가 되었을 때 함수 선언문은 반환값의 타입이 void이지만 함수 표현식은 never가 된다.

## 2.7.6 타입 간 대입 가능표

외우는 것보단 직접 대입하고 에러나면 바꾸는 것이 낫다.

# 2.8 타입 별칭으로 타입에 이름을 붙이자.

기존 타입에 새로 이름을 붙인 것을 타입 별칭(type alias)라고 한다. type 키워드를 사용해서 선언할 수 있다.
타입 별칭을 관례적으로 대문자로 시작하는 단어로 만든다.

```typescript
type A = string;
const str: A = "hello";

type ValueWithUnit = (value: number, unit: string) => string;
const func2: ValueWithUnit = (value, unit) => value + unit;

type Person = {
  name: string;
  age: number;
};

const person1: Person = {
  name: "현주",
  age: 20,
};
```

# 2.9 인터페이스로 객체를 타이핑하자.

인터페이스(interface) 선언을 사용하는 것. 이름은 타입 별칭과 마찬가지로 대문자로 시작하는 단어를 만드는 것이 관례.
인터페이스를 입력할 때 콤마나 세미콜론, 줄바꿈으로 구분할 수 있는데 한가지 방식으로 사용할 것은 권장한다.

```typescript
interface Arr {
  length: number;
  [key: number]: string;
}

const arr: Arr = ["3", "5", "7"];

arr.slice();
// Error: Property 'slice' does not exist on type 'Arr'.
```

인덱스 시그니처(Index Signature) : 이 객체의 length를 제외한 속성 키가 전부 number라는 의미이다. Arr 인터페이스는 배열을 정확하게 구현한 것이 아니므로 배열 내장 메서드를 사용할 수 없다.
내장 메서드를 사용할 수 있는 방법은 2.10에서 알아보자.

## 2.9.1 인터페이스 선언 병합

같은 이름으로 여러 인터페이스를 선언할 수 있다. 대신 하나로 합쳐진다.

## 2.9.2 네임스페이스

같은 이름을 사용하면 인터페이스가 병합되어 원하지 않는 결과를 낳게 된다. 네임스페이스(namespace)를 사용하면 객체처럼 접근하여 사용가능하다. 단, 네임스페이스 안에 객체를 export를 해야 한다.

네임스페이스 내부에 실제 값을 선언하여 사용할 수 있다. `[]`를 사용해서 접근할 수 있으나 타입이나 인터페이스는 `[]`를 사용해서 접근할 수 없다.

```typescript
namespace Example {
  export interface Inner {
    test: string;
  }
  export type test2 = number;
  export const a = "real";
}

const ex1: Example.Inner = {
  test: "hi",
};
const ex2: Example.test2 = 3;
const ex3 = Example.a;
const ex4 = Example["a"];
// ❌
const ex5: Example["test2"] = 5;
// Cannot use namespace 'Example' as a type.
```

네임스페이스도 이름이 겹치는 경우 병합이 된다.
내부에 같은 이름의 인터페이스가 있으면 합쳐지고, 내부에 같은 이름의 타입이 있다면 에러가 난다.

# 2.10 객체의 속성과 메서드에 적용되는 특징을 알자

객체의 속성에 적용되는 특징은 인터페이스로 선언했든, 타입 별칭으로 선언했든 상관없이 공통적으로 적용된다.

옵셔널(optional)이나 readonly 수식어가 가능하다.

```typescript
// 전개 문법과 나머지 속성
const {
  prop: { nested, ...rest },
} = { prop: { nested: "hi", a: 1, b: true } };
const spread = { a: "hi", b: 123 };
const obj = { ...spread };

// 구조분해 할당할 때 많이 실수하는 것
// ❌ 잘못된 예시
const {
  prop: { nested: string },
} = {
  prop: { nested: "hi" },
};
// const string: string

// 👍 올바른 예시
const {
  prop: { nested },
}: { prop: { nested: string } } = {
  prop: { nested: "hi" },
};
```

기본적으로 객체를 타이핑할 때 (객체 리터럴 대입) 선언하지 않은 속성에 대해서는 에러가 발생하지만 변수를 대입했을 때는 에러가 발생하지 않는다. 그 이유는 객체 리터럴을 대입했을 때 타입스크립트가 잉여 속성 검사(Excess Property Checking)를 실행하기 때문이다. 잉여 속성 검사는 타입 선언에서 선언하지 않은 속성을 사용할 때 에러를 표시하는 것을 의미한다.

## 2.10.1 인덱스 접근 타입

```typescript
type Animal = {
  name: string;
};
// ❌ 잘못된 예시
type N3 = Animal.name;
// type N3 = Animal['name']
```

특정 속성의 타입을 별도 타입으로 만들고 싶다면 `객체["속성"]` 방식으로 접근해야 한다. `객체.속성` 방식으로 접근할 수 없다. 이렇게 객체 속성의 타입에 접근하는 방식을 인덱스 접근 타입(Indexed Acess Type)이라고 한다.

```typescript
const obj = {
  hello: "world",
  name: "zero",
  age: 28,
};
type Keys = keyof typeof obj;
// type Keys = "hello" | "name" | "age"
type Values = (typeof obj)[Keys];
// type Values = string | number
```

keyof 연산자와 인덱스 접근 타입을 활용해 키의 타입과 값의 타입을 구할 수 있다.

```typescript
interface Examples {
  a(): void; // 메서드(매개변수): 반환값
  b: () => void; // 메서드: (매개변수) => 반환값
  c: {
    // 메서드:{ (매개변수): 반환값 }
    (): void;
  };
}
```

객체의 메서드를 선언할 때는 세가지 방식으로 사용할 수 있다.

## 2.10.2 매핑된 객체 타입

객체의 일부 속성만 타입을 지정할 수 있다.

매핑된 객체 타입(Mapped Object Type) 기능을 사용하여 기존 객체 타입을 기반으로 새로운 객체 타입을 만들 수 있다. `keyof` 와 함께 사용되며 객체 타입의 키(프로퍼티 이름)를 추출하는데 사용된다.

코드를 반복하지 않고 선택적으로 만들 수 있다.

```ts
type Person = {
  name: string;
  age: number;
  location: string;
};

// 모든 프로퍼티를 선택적으로 만드는 매핑된 객체 타입
type PartialPerson = {
  [key in keyof Person]?: Person[key];
};

// PartialPerson 타입 사용
const partialPerson: PartialPerson = {
  name: "Alice",
  age: 30,
};

// 수식어 readonly와 ? 사용
type Copy = {
  readonly [key in keyof Person]?: Person[key];
};
/*
	type Copy = {
	    readonly name?: string | undefined;
	    readonly age?: number | undefined;
	    readonly location?: string | undefined;
	}
*/

// 수식어 제거하는 방법
type Remove = {
  -readonly [key in keyof Copy]-?: Copy[key];
};
/*
	수식어 `readonly`와 `?` 앞에 `-`를 붙여서 readonly와 ? 수식어가 제거되었다.
	type 수식어제거 = {
	    name: string;
	    age: number;
	    location: string;
	}
*/

// as 예약어를 통해 속성 이름을 바꿀지 정할 수 있다.
// Capitalize는 타입스크립트에서 제공하는 타입으로 문자열의 첫 번째 자리를 대문자화한다.
// key가 서버에서는 대문자로 내려오고 프론트에서는 소문자로 내려올 때 쓰면 좋을 것 같다.
type CapitalizeCopy = {
  [key in keyof Person as Capitalize<key>]: Person[key];
};
/*
	type CapitalizeCopy = {  
		Name: string;  
		Age: number;  
		Location: string;  
	}
*/
```

# 2.11 타입을 집합으로 생각하자 (유니언, 인터섹션)

교집합을 나타내는 연산자는 `&`이다. 타입을 집합으로 생각하면 전체집합은 unknown, 공집합은 never로 생각할 수 있다. &은 교집합, |는 합집합이 된다.

null/undefined를 제외한 원시 자료형과 비어 있지 않은 객체를 & 연산할 때 never가 되지 않는다.

# 2.12 타입도 상속이 가능하다.

extends 예약어를 사용하여 기존 타입을 상속할 수 있다. 중복으로 선언하는 것을 막을 수 있다.
타입 별칭도 교집합을 뜻하는 `&`를 사용하여 상속이 가능하다.

```ts
type Animal = {
  name: string;
};

type Dog = Animal & {
  bark(): void;
};

type Cat = Animal & {
  meow(): void;
};

type Name = Cat["name"];
```

타입 별칭이 인터페이스를 상속할 수 있고, 인터페이스가 타입 별칭을 상속할 수도 있다.

```ts
interface Animal {
  name: string;
}

type Cat = Animal & {
  meow(): void;
};
```

```ts
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}
```

한 번에 여러 타입을 상속할 수 있고, 상속할 때 부모 속성의 타입을 변경할 수 있다. 단, 완전히 다른 타입으로 변경하면 에러가 발생한다.

```tsx
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}

interface Cat extends Animal {
  meow(): void;
}

interface DogCat extends Dog, Cat {}
// ✅ 더 좁은 타입으로 상속할 수 있다.
interface DogCat1 extends Dog, Cat {
  name: "강아지";
}
// ❌ 완전히 다른 타입으로 변경하면 에러가 발생한다.
interface DogCat2 extends Dog, Cat {
  name: 123;
}
```

# 2.13 객체 간에 대입할 수 있는지 확인하는 법을 배우자.

> [!tip]
> 좁은 타입과 넓은 타입에 대해 이해를 할 것.

⭕️ 좁은 타입 => 넓은 타입
❌ 넓은 타입 => 좁은 타입

```ts
interface A {
  name: string;
}

interface B {
  name: string;
  age: number;
}
```

A타입이 B타입보다 더 넓은 타입입니다. B가 코드의 양과 줄 수가 더 많아서 B가 넓다고 생각할 수 있지만 코드의 양과 줄 수가 더 많은 이유는 그만큼 더 구체적으로 적었기 때문이다. 구체적이라는 것은 조건을 만족하기 더 힘들다는 뜻이고, 더 좁은 타입이라는 것이다.

튜플은 배열보다 좁은 타입이다.
string[]이 readonly string[]보다 더 좁은 타입이다.
두 객체가 있고 속성이 동일할 때, 속성이 옵셔널인 객체가 옵셔널이지 않은 객체보다 더 넓은 타입이다.
옵셔널이란 기존 타입에 undefined가 유니언된 것과 같다. `기존 타입 | undefined`가 기존 타입보다 넓은 타입이므로 옵셔널 객체가 더 넓은 타입이다.

## 2.13.1 구조적 타이핑

타입스크립트에서는 모든 속성이 동일하면 객체 타입의 이름이 다르더라도 동일한 타입으로 취급한다. 이것을 **구조적 타이핑(structural typing)** 이라 한다.

구조적으로 동일하지 않게 만들려면 **브랜드(brand) 속성**을 추가하면 된다. 아래의 예시처럼 꼭 `__type` 이 아니어도 되며 다른 속성과 겹치지 않는 이름이면 된다. 브랜드 속성을 사용하는 것을 브랜딩(branding) 한다고 표현한다.

```tsx
interface Money {
  __type: "money";
  amount: number;
  unit: string;
}

interface Liter {
  __type: "liter";
  amount: number;
  unit: string;
}
```

# 2.14 제네릭으로 타입을 함수처럼 사용하자.

> [!tip]
> 제네릭을 함수라고 생각하자. 함수의 매개변수에 호출할 때 넣은 인수가 대응되는 것처럼!

```tsx
interface Joo {
  type: "humam";
  race: "yellow";
  name: "Joo";
  age: 37;
}

interface Kiu {
  type: "humam";
  race: "yellow";
  name: "Kiu";
  age: 20;
}
```

type과 race 속성의 타입은 동일한데, name과 age 속성의 타입은 다르다. 제네릭(Generic)을 사용하여 중복을 제거할 수 있다.

```ts
interface Person<N, A> {
  type: "humam";
  race: "yellow";
  name: N;
  age: A;
}

interface Joo extends Person<"Joo", 37> {}
interface Kiu extends Person<"Kiu", 20> {}
```

제네릭 표기는 `<>`로 하며 인터페이스 이름 바로 뒤에 위치한다. <>안에 타입 매개변수(Type Parameter)를 넣으면 된다. 선언한 제네릭을 사용할 때는 매개변수에 대응하는 실제 타입 인수(Type Argument)를 넣으면 된다.

❗️ 제네릭은 다음과 같은 위치를 사용해야 한다. (암기할 것)

- `interface 이름<타입 매개변수들> {...}`
- `type 이름<타입 매개변수들> = {...}`
- `class 이름<타입 매개변수들> {...}`
- `function 이름<타입 매개별수들>(...) {...}`
- `const 함수이름 = <타입 매개변수들>(...) => {...}`

제네릭에 직접 타입을 넣지 않아도 추론을 통해 타입을 알 수 있으며, 실제로 직접 넣지 않은 경우가 더 많다.

```tsx
function values<const T>(initial: T[]) {
  return {
    hasValue(value: T) {
      return initial.includes(value);
    },
  };
}

const saveValues = values(["a", "b", "c"]);
saveValues.hasValue("x");
```

> [!question]
> 여기서 이야기하는 상수 타입 매개변수는 무엇일까?
> 유니언으로 추론한다는 건 뭐지??

## 2.14.1 제네릭에 제약 걸기

타입 매개변수에 제약(constraint)을 사용할 수 있다. 타입 매개변수 A의 타입은 숫자 타입이어야 한다는 뜻이다.
제약이 걸리면 제약에 어긋나는 타입은 입력할 수 없지만 제약보다 더 구체적인 타입은 입력할 수 있다.

```ts
interface Example<A extends number, B = string> {
  // B = 타입 방식으로 기본값을 설정할 수 있다.
  a: A;
  b: B;
}

type UseCase1 = Example<string, boolean>;
// Type 'string' does not satisfy the constraint 'number'.
// number 타입으로 제약을 했으므로 제약에 어긋나는 타입을 입력하면 에러가 난다.

type UseCase2 = Example<1, boolean>;
// number 타입의 구체적인 타입인 리터럴 1은 입력할 수 있다.
type UseCase3 = Example<number>;
// 기본값을 설정하였기 때문에 B를 입력하지 않아도 된다.

const useCase3: UseCase3 = { a: 1, b: false };
// Type 'boolean' is not assignable to type 'string'.
// The expected type comes from property 'b' which is declared here on type
// 타입 별칭을 선언할 때 기본값인 string 타입으로 설정했으므로 boolean 타입을 넣어서 에러가 났다.
```

하나의 타입 매개변수가 다른 타입 매개변수의 제약이 될 수 있다.

```ts
interface Example<A, B extends A> {
  // B 타입 매개변수는 A 타입이어야 한다.
  a: A;
  b: B;
}

type UseCase1 = Example<string, number>;
// Type 'number' does not satisfy the constraint 'string'.
type UseCase2 = Example<string, "123">;
type UseCase3 = Example<number, 123>;
```

자주쓰는 제약들이 존재한다. 각각 타입 매개변수가 객체, 배열, 함수, 생성자, 속성의 키여야 한다는 제약을 나타낸다.

```ts
<T extends object> // 모든 객체
<T extends any[]> // 모든 배열
<T extends (...args: any) => any> // 모든 함수
<T extends abstract new (...args: any) => any> // 생성자 타입
<T extends keyof any> // string | number | symbol
```
