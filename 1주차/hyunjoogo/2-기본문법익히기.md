# 2.1 λ³€μ, λ§¤κ°λ³€μ, λ°ν™κ°’μ— νƒ€μ…μ„ λ¶™μ΄λ©΄ λλ‹¤.

- νƒ€μ…μ„ λ¶™μ΄λ” ν–‰μ„λ¥Ό νƒ€μ΄ν•‘(Typing)μ΄λΌκ³  ν•λ‹¤.
- λ³€μ, ν•¨μμ λ§¤κ°λ³€μμ™€ λ°ν™κ°’μ— νƒ€μ΄ν•‘μ„ ν•λ‹¤.
- νƒ€μ…μ μΆ…λ¥μ—λ” string, number, boolean, null, undefined, symbol, bigint, object(κ°μ²΄μ™€ λ°°μ—΄)μ΄ μλ‹¤.

# 2.2 νƒ€μ…μ¶”λ΅ μ„ μ κ·Ή ν™μ©ν•μ.

- νƒ€μ…μ¤νΈλ¦½νΈλ” μ•μ•„μ„ νƒ€μ…μ„ μ¶”λ΅ ν•λ‹¤. λ‹¨, λ§¤κ°λ³€μλ” νƒ€μ…μ„ λ¶€μ—¬ν•΄μ•Ό ν•λ‹¤.

> [!tip]
> νƒ€μ…μ¤ν¬λ¦½νΈκ°€ νƒ€μ… μ¶”λ΅ μ„ μ λ€λ΅ ν•λ©΄ μ“°κ³ , ν‹€λ¦¬λ©΄ νƒ€μ…μ„ ν‘κΈ°ν•μ.

1. λ¦¬ν„°λ΄ νƒ€μ… : νƒ€μ…μ— κ°’μ„ μ§μ ‘ μ…λ ¥ν• νƒ€μ…
2. λ„“μ€ λ²”μ„ νƒ€μ…μΌλ΅ ν‘κΈ°ν•΄λ„ λ¨

- letμΌλ΅ μ„ μ–Έν• λ³€μλ” λ‹¤λ¥Έ κ°’μ„ λ€μ…ν•  μ μκΈ°μ— νƒ€μ…μ„ λ„“κ² μ¶”λ΅ ν•λ”λ° μ΄λ¬ν• ν„μƒμ€ νƒ€μ…λ„“νκΈ° (Type Widning)μ΄λΌκ³  ν•λ‹¤.

```typescript
const str1 = "hello";
// const str1 : 'hello'
let str2 = "hello";
// let str2 : string
```

# 2.3 κ°’ μμ²΄κ°€ νƒ€μ…μΈ λ¦¬ν„°λ΄ νƒ€μ…μ΄ μλ‹¤

λ¦¬ν„°λ΄ νƒ€μ…μ€ νƒ€μ…μ— κ°’μ„ μ§μ ‘ μ…λ ¥ν• νƒ€μ…μ΄λ‹¤.
μ›μ‹ μλ£ν•, κ°μ²΄, λ°°μ—΄, ν•¨μλ„ κ°€λ¥ν•λ‹¤.

```typescript
let str1: "hello" = "hello";
str1 = "world";
// λ³€κ²½ λ¶κ°€

const obj: { name: "zero" } = { name: "zero" };
const arr: [1, "1"] = [1, "1"];
const func: (a: number, b: number) => number = (a, b) => a + b;
```

# 2.4 λ°°μ—΄ λ§κ³  νν”λ„ μλ‹¤.

λ°°μ—΄μ μ΅΄μ¬ν•μ§€ μ•λ” indexμ— μ ‘κ·Όν•  μ μλ‹¤.

```typescript
const arr3 = [1, 3, 5];
arr3[3].toFixed();
```

μ΄λ¬ν• μ ‘κ·Όμ„ λ§‰κΈ° μ„ν•΄ κ° μ”μ† μλ¦¬μ— νƒ€μ…μ΄ κ³ μ •λμ–΄ μλ” λ°°μ—΄μ„ μλ―Έν•λ” νν”(tuple)μ„ μ‚¬μ©ν•λΌ.

```typescript
const tuple: [number, string, boolean] = [1, "1", false];

tuple[3] = "no";
// μ—λ¬ λ°μƒ
```

push, pop, unshift, shift λ©”μ„λ“κΉμ§€ λ§‰κ³  μ‹¶λ‹¤λ©΄ readonlyλ¥Ό μ‚¬μ©ν•λΌ.

```typescript
const tuple: readonly [number, string, boolean] = [1, "1", false];

tuple.push("no");
// μ—λ¬ λ°μƒ
```

> [!tip]
> λ°°μ—΄λ³΄λ‹¤ μ •κµν• νƒ€μ… κ²€μ‚¬λ¥Ό μ›ν•λ‹¤λ©΄ νν”μ„ μ‚¬μ©ν•λΌ.

μ „κ° λ¬Έλ²•, λ‚λ¨Έμ§€ μ†μ„± λ¬Έλ²•μΌλ΅ νƒ€μ…ν‘μ‹κ°€ κ°€λ¥ν•λ‹¤.
κ°’μ„ μ „κ°ν•΄λ„ νƒ€μ…μ¤ν¬λ¦½νΈλ” νƒ€μ… μ¶”λ΅ μ„ ν•λ‹¤.

```typescript
const strNumBools: [string, number, ...boolean[]] = [
  "1",
  1,
  false,
  true,
  false,
];

const arr1 = ["hi", true];
const arr = [46, ...arr1];
// const arr: (string | number | boolean)[]

const [a, ...rest1] = ["hi", true, false];
// const a: string
// const rest1: [boolean, boolean]
```

μµμ…”λ„(optional) μμ‹μ–΄λ„ κ°€λ¥ν•λ‹¤.

```typescript
let tuple: [number, boolean?, string?] = [1, false, "hi"];
// let tuple: [number, (boolean | undefined)?, (string | undefined)?]
```

# 2.5 νƒ€μ…μΌλ΅ μ“Έ μ μλ” κ²ƒμ„ κµ¬λ¶„ν•μ

λ‚΄μ¥ κ°μ²΄ νƒ€μ… μ¤‘ String, Object, Number, Boolean, Symbolμ€ μ‚¬μ©ν•μ§€ λ§μ.

ν•¨μ μ„ μ–Έν•μ€ νΈμ¶μ΄ μ•„λ‹λΌλ©΄ typeofλ¥Ό μ‚¬μ©ν•μ—¬ νƒ€μ…μΌλ΅ μ“Έ μ μλ‹¤.

```typescript
function add(x:number, y:number) {
  return x + y;
}
const add2 : typeof add = (x:number, y:number) => x + y;
const add3 : add(1, 2) = (x:number, y:number) => x + y;
// μ—λ¬λ°μƒ
```

ν΄λμ¤λ” typeof μ—†μ΄λ„ μ‚¬μ©μ΄ κ°€λ¥ν•λ‹¤.

# 2.6 μ λ‹μ–Έ νƒ€μ…μΌλ΅ OR κ΄€κ³„λ¥Ό ν‘ν„ν•μ

νμ΄ν”„ μ—°μ‚°μ(|)λ¥Ό μ‚¬μ©ν• μ λ‹μ–Έ νƒ€μ…μ€ ν•λ‚μ λ³€μκ°€ μ—¬λ¬ νƒ€μ…μ„ κ°€μ§ μ μλ” κ°€λ¥μ„±μ„ ν‘μ‹ν•λ” κ²ƒμ΄λ‹¤.

```typescript
function returnString(value: number | string) {
  return value.toString();
}
```

# 2.7 νƒ€μ…μ¤ν¬λ¦½νΈμ—λ§ μλ” νƒ€μ…μ„ λ°°μ°μ

## 2.7.1. any

anyλ” νƒ€μ…μ¤ν¬λ¦½νΈμ—μ„ μ§€μ–‘ν•΄μ•Ό ν•  νƒ€μ…μ΄λ‹¤.

> [!tip]
> any νƒ€μ…μ€ νƒ€μ… κ²€μ‚¬λ¥Ό ν¬κΈ°ν•λ‹¤λ” μ„ μ–Έκ³Ό κ°™λ‹¤. νƒ€μ…μ¤ν¬λ¦½νΈκ°€ anyλ΅ μ¶”λ΅ ν•λ” νƒ€μ…μ΄ μλ‹¤λ©΄ νƒ€μ…μ„ μ§μ ‘ ν‘κΈ°ν•΄μ•Ό ν•λ‹¤.

νƒ€μ…μ¤ν¬λ¦½νΈκ°€ λ…μ‹μ μΌλ΅ anyλ¥Ό λ°ν™ν•λ” JSON.parseμ™€ fetch ν•¨μμ—λ” νƒ€μ…μ„ μ§μ ‘ ν‘κΈ°ν•΄μ•Ό ν•λ‹¤.

```typescript
fetch("url")
  .then((response) => {
    return response.json();
  })
  .then((result) => {});
// (parameter) result: any

const result = JSON.parse('{"hello":"json"}');
// const result: any
```

μ•„λμ™€ κ°™μ΄ νƒ€μ…μ„ ν‘μ‹ν•μ.

```typescript
fetch("url")
  .then<{ data: string }>((response) => {
    return response.json();
  })
  .then((result) => {});
// (parameter) result: {data:string}

const result: { hello: string } = JSON.parse('{"hello":"json"}');
// const result: {hello : string}
```

## 2.7.2. unknown

any νƒ€μ…κ³Ό λΉ„μ·ν•μ§€λ§ νƒ€μ… ν‘μ‹ ν›„ μ–΄λ– ν• λ™μ‘λ„ ν•  μ μ—†κ² λλ‹¤.

```typescript
const a: unknown = "hello";
a.slice();
// 'a' is of type 'unknown'.
```

try/catchλ¬Έμ—μ„ unknwonμ„ λ³΄κ² λλ‹¤. unknwonμ΄λ―€λ΅ κ·Έ λ’¤μ— μ–΄λ– ν• λ™μ‘λ„ ν•  μ μ—†λ‹¤.
`catch(e : νƒ€μ…)`μ²λΌ μ§μ ‘ νƒ€μ΄ν•‘μ„ ν•  μ μ—†μΌλ―€λ΅ asλ΅ νƒ€μ…μ„ μ£Όμ¥(Type Assertion)μ„ ν•΄μ•Ό ν•λ‹¤.

```typescript
try {
} catch (e) {
  console.log(e.message);
}
// 'e' is of type 'unknown'.

try {
} catch (e) {
  const error = e as Error;
  console.log(error.message);
}
```

as κ°™μ€ κ²ƒμΌλ΅ !(non-null assertion) μ—°μ‚°μκ°€ μλ‹¤. null λΏλ§ μ•„λ‹λΌ undefinedλ„ μ•„λ‹μ„ μ£Όμ¥ν•  μ μλ‹¤.

```typescript
function a(param: string | null | undefined) {
  param.slice(3);
}
// 'param' is possibly 'null' or 'undefined'

function a(param: string | null | undefined) {
  param!.slice(3);
}
```

## 2.7.3 void

voidλ” ν•¨μμ λ°ν™κ°’μ„ λ¬΄μ‹ν•λ„λ΅ ν•λ” νΉμ νƒ€μ…μ΄λ‹¤. ν•¨μμ λ°ν™κ°’μ΄ μ—†λ” κ²½μ° λ°ν™κ°’μ΄ void νƒ€μ…μΌλ΅ μ¶”λ΅ λλ‹¤.

## 2.7.4 {}, Object

λ€λ¬Έμ Oμ΄λ‹¤. nullκ³Ό undefinedλ¥Ό μ μ™Έν• λ¨λ“  κ°’μ„ μλ―Έν•λ‹¤. λ€μ…μ€ κ°€λ¥ν•μ§€λ§ μ‚¬μ©ν• μ μ—†μΌλ―€λ΅ νƒ€μ΄ν•‘ν•λ” μλ―Έκ°€ λ¬΄μƒ‰ν•λ‹¤.

## 2.7.5 never

never νƒ€μ…μ—λ” μ–΄λ– ν• νƒ€μ…λ„ λ€μ…ν•  μ μ—†λ‹¤. ν•¨μ μ„ μ–Έλ¬Έκ³Ό ν•¨μ ν‘ν„μ‹μΌ λ• μ°¨μ΄κ°€ μλ‹¤.

> [!tip]
> ν•¨μ μ„ μ–Έλ¬Έμ€ `function ν•¨μλ…() {}`μΌλ΅ μ„ μ–Έν• ν•¨μμ΄λ‹¤.
> ν•¨μ ν‘ν„μ‹μ€ `const ν•¨μλ… = () => {}` λ΅ ν‘ν„ν• ν•¨μμ΄λ‹¤.

throwκ°€ λμ—μ„ λ• ν•¨μ μ„ μ–Έλ¬Έμ€ λ°ν™κ°’μ νƒ€μ…μ΄ voidμ΄μ§€λ§ ν•¨μ ν‘ν„μ‹μ€ neverκ°€ λλ‹¤.

## 2.7.6 νƒ€μ… κ°„ λ€μ… κ°€λ¥ν‘

μ™Έμ°λ” κ²ƒλ³΄λ‹¨ μ§μ ‘ λ€μ…ν•κ³  μ—λ¬λ‚λ©΄ λ°”κΎΈλ” κ²ƒμ΄ λ‚«λ‹¤.

# 2.8 νƒ€μ… λ³„μΉ­μΌλ΅ νƒ€μ…μ— μ΄λ¦„μ„ λ¶™μ΄μ.

κΈ°μ΅΄ νƒ€μ…μ— μƒλ΅ μ΄λ¦„μ„ λ¶™μΈ κ²ƒμ„ νƒ€μ… λ³„μΉ­(type alias)λΌκ³  ν•λ‹¤. type ν‚¤μ›λ“λ¥Ό μ‚¬μ©ν•΄μ„ μ„ μ–Έν•  μ μλ‹¤.
νƒ€μ… λ³„μΉ­μ„ κ΄€λ΅€μ μΌλ΅ λ€λ¬Έμλ΅ μ‹μ‘ν•λ” λ‹¨μ–΄λ΅ λ§λ“ λ‹¤.

```typescript
type A = string;
const str: A = "hello";

type ValueWithUnit = (value: number, unit: string) => string;
const func2: ValueWithUnit = (value, unit) => value + unit;

type Person = {
  name: string;
  age: number;
};

const person1: Person = {
  name: "ν„μ£Ό",
  age: 20,
};
```

# 2.9 μΈν„°νμ΄μ¤λ΅ κ°μ²΄λ¥Ό νƒ€μ΄ν•‘ν•μ.

μΈν„°νμ΄μ¤(interface) μ„ μ–Έμ„ μ‚¬μ©ν•λ” κ²ƒ. μ΄λ¦„μ€ νƒ€μ… λ³„μΉ­κ³Ό λ§μ°¬κ°€μ§€λ΅ λ€λ¬Έμλ΅ μ‹μ‘ν•λ” λ‹¨μ–΄λ¥Ό λ§λ“λ” κ²ƒμ΄ κ΄€λ΅€.
μΈν„°νμ΄μ¤λ¥Ό μ…λ ¥ν•  λ• μ½¤λ§λ‚ μ„Έλ―Έμ½λ΅ , μ¤„λ°”κΏμΌλ΅ κµ¬λ¶„ν•  μ μλ”λ° ν•κ°€μ§€ λ°©μ‹μΌλ΅ μ‚¬μ©ν•  κ²ƒμ€ κ¶μ¥ν•λ‹¤.

```typescript
interface Arr {
  length: number;
  [key: number]: string;
}

const arr: Arr = ["3", "5", "7"];

arr.slice();
// Error: Property 'slice' does not exist on type 'Arr'.
```

μΈλ±μ¤ μ‹κ·Έλ‹μ²(Index Signature) : μ΄ κ°μ²΄μ lengthλ¥Ό μ μ™Έν• μ†μ„± ν‚¤κ°€ μ „λ¶€ numberλΌλ” μλ―Έμ΄λ‹¤. Arr μΈν„°νμ΄μ¤λ” λ°°μ—΄μ„ μ •ν™•ν•κ² κµ¬ν„ν• κ²ƒμ΄ μ•„λ‹λ―€λ΅ λ°°μ—΄ λ‚΄μ¥ λ©”μ„λ“λ¥Ό μ‚¬μ©ν•  μ μ—†λ‹¤.
λ‚΄μ¥ λ©”μ„λ“λ¥Ό μ‚¬μ©ν•  μ μλ” λ°©λ²•μ€ 2.10μ—μ„ μ•μ•„λ³΄μ.

## 2.9.1 μΈν„°νμ΄μ¤ μ„ μ–Έ λ³‘ν•©

κ°™μ€ μ΄λ¦„μΌλ΅ μ—¬λ¬ μΈν„°νμ΄μ¤λ¥Ό μ„ μ–Έν•  μ μλ‹¤. λ€μ‹  ν•λ‚λ΅ ν•©μ³μ§„λ‹¤.

## 2.9.2 λ„¤μ„μ¤νμ΄μ¤

κ°™μ€ μ΄λ¦„μ„ μ‚¬μ©ν•λ©΄ μΈν„°νμ΄μ¤κ°€ λ³‘ν•©λμ–΄ μ›ν•μ§€ μ•λ” κ²°κ³Όλ¥Ό λ‚³κ² λλ‹¤. λ„¤μ„μ¤νμ΄μ¤(namespace)λ¥Ό μ‚¬μ©ν•λ©΄ κ°μ²΄μ²λΌ μ ‘κ·Όν•μ—¬ μ‚¬μ©κ°€λ¥ν•λ‹¤. λ‹¨, λ„¤μ„μ¤νμ΄μ¤ μ•μ— κ°μ²΄λ¥Ό exportλ¥Ό ν•΄μ•Ό ν•λ‹¤.

λ„¤μ„μ¤νμ΄μ¤ λ‚΄λ¶€μ— μ‹¤μ  κ°’μ„ μ„ μ–Έν•μ—¬ μ‚¬μ©ν•  μ μλ‹¤. `[]`λ¥Ό μ‚¬μ©ν•΄μ„ μ ‘κ·Όν•  μ μμΌλ‚ νƒ€μ…μ΄λ‚ μΈν„°νμ΄μ¤λ” `[]`λ¥Ό μ‚¬μ©ν•΄μ„ μ ‘κ·Όν•  μ μ—†λ‹¤.

```typescript
namespace Example {
  export interface Inner {
    test: string;
  }
  export type test2 = number;
  export const a = "real";
}

const ex1: Example.Inner = {
  test: "hi",
};
const ex2: Example.test2 = 3;
const ex3 = Example.a;
const ex4 = Example["a"];
// β
const ex5: Example["test2"] = 5;
// Cannot use namespace 'Example' as a type.
```

λ„¤μ„μ¤νμ΄μ¤λ„ μ΄λ¦„μ΄ κ²ΉμΉλ” κ²½μ° λ³‘ν•©μ΄ λλ‹¤.
λ‚΄λ¶€μ— κ°™μ€ μ΄λ¦„μ μΈν„°νμ΄μ¤κ°€ μμΌλ©΄ ν•©μ³μ§€κ³ , λ‚΄λ¶€μ— κ°™μ€ μ΄λ¦„μ νƒ€μ…μ΄ μλ‹¤λ©΄ μ—λ¬κ°€ λ‚λ‹¤.

# 2.10 κ°μ²΄μ μ†μ„±κ³Ό λ©”μ„λ“μ— μ μ©λλ” νΉμ§•μ„ μ•μ

κ°μ²΄μ μ†μ„±μ— μ μ©λλ” νΉμ§•μ€ μΈν„°νμ΄μ¤λ΅ μ„ μ–Έν–λ“ , νƒ€μ… λ³„μΉ­μΌλ΅ μ„ μ–Έν–λ“  μƒκ΄€μ—†μ΄ κ³µν†µμ μΌλ΅ μ μ©λλ‹¤.

μµμ…”λ„(optional)μ΄λ‚ readonly μμ‹μ–΄κ°€ κ°€λ¥ν•λ‹¤.

```typescript
// μ „κ° λ¬Έλ²•κ³Ό λ‚λ¨Έμ§€ μ†μ„±
const {
  prop: { nested, ...rest },
} = { prop: { nested: "hi", a: 1, b: true } };
const spread = { a: "hi", b: 123 };
const obj = { ...spread };

// κµ¬μ΅°λ¶„ν•΄ ν• λ‹Ήν•  λ• λ§μ΄ μ‹¤μν•λ” κ²ƒ
// β μλ»λ μμ‹
const {
  prop: { nested: string },
} = {
  prop: { nested: "hi" },
};
// const string: string

// π‘ μ¬λ°”λ¥Έ μμ‹
const {
  prop: { nested },
}: { prop: { nested: string } } = {
  prop: { nested: "hi" },
};
```

κΈ°λ³Έμ μΌλ΅ κ°μ²΄λ¥Ό νƒ€μ΄ν•‘ν•  λ• (κ°μ²΄ λ¦¬ν„°λ΄ λ€μ…) μ„ μ–Έν•μ§€ μ•μ€ μ†μ„±μ— λ€ν•΄μ„λ” μ—λ¬κ°€ λ°μƒν•μ§€λ§ λ³€μλ¥Ό λ€μ…ν–μ„ λ•λ” μ—λ¬κ°€ λ°μƒν•μ§€ μ•λ”λ‹¤. κ·Έ μ΄μ λ” κ°μ²΄ λ¦¬ν„°λ΄μ„ λ€μ…ν–μ„ λ• νƒ€μ…μ¤ν¬λ¦½νΈκ°€ μ‰μ—¬ μ†μ„± κ²€μ‚¬(Excess Property Checking)λ¥Ό μ‹¤ν–‰ν•κΈ° λ•λ¬Έμ΄λ‹¤. μ‰μ—¬ μ†μ„± κ²€μ‚¬λ” νƒ€μ… μ„ μ–Έμ—μ„ μ„ μ–Έν•μ§€ μ•μ€ μ†μ„±μ„ μ‚¬μ©ν•  λ• μ—λ¬λ¥Ό ν‘μ‹ν•λ” κ²ƒμ„ μλ―Έν•λ‹¤.

## 2.10.1 μΈλ±μ¤ μ ‘κ·Ό νƒ€μ…

```typescript
type Animal = {
  name: string;
};
// β μλ»λ μμ‹
type N3 = Animal.name;
// type N3 = Animal['name']
```

νΉμ • μ†μ„±μ νƒ€μ…μ„ λ³„λ„ νƒ€μ…μΌλ΅ λ§λ“¤κ³  μ‹¶λ‹¤λ©΄ `κ°μ²΄["μ†μ„±"]` λ°©μ‹μΌλ΅ μ ‘κ·Όν•΄μ•Ό ν•λ‹¤. `κ°μ²΄.μ†μ„±` λ°©μ‹μΌλ΅ μ ‘κ·Όν•  μ μ—†λ‹¤. μ΄λ ‡κ² κ°μ²΄ μ†μ„±μ νƒ€μ…μ— μ ‘κ·Όν•λ” λ°©μ‹μ„ μΈλ±μ¤ μ ‘κ·Ό νƒ€μ…(Indexed Acess Type)μ΄λΌκ³  ν•λ‹¤.

```typescript
const obj = {
  hello: "world",
  name: "zero",
  age: 28,
};
type Keys = keyof typeof obj;
// type Keys = "hello" | "name" | "age"
type Values = (typeof obj)[Keys];
// type Values = string | number
```

keyof μ—°μ‚°μμ™€ μΈλ±μ¤ μ ‘κ·Ό νƒ€μ…μ„ ν™μ©ν•΄ ν‚¤μ νƒ€μ…κ³Ό κ°’μ νƒ€μ…μ„ κµ¬ν•  μ μλ‹¤.

```typescript
interface Examples {
  a(): void; // λ©”μ„λ“(λ§¤κ°λ³€μ): λ°ν™κ°’
  b: () => void; // λ©”μ„λ“: (λ§¤κ°λ³€μ) => λ°ν™κ°’
  c: {
    // λ©”μ„λ“:{ (λ§¤κ°λ³€μ): λ°ν™κ°’ }
    (): void;
  };
}
```

κ°μ²΄μ λ©”μ„λ“λ¥Ό μ„ μ–Έν•  λ•λ” μ„Έκ°€μ§€ λ°©μ‹μΌλ΅ μ‚¬μ©ν•  μ μλ‹¤.

## 2.10.2 λ§¤ν•‘λ κ°μ²΄ νƒ€μ…

κ°μ²΄μ μΌλ¶€ μ†μ„±λ§ νƒ€μ…μ„ μ§€μ •ν•  μ μλ‹¤.

λ§¤ν•‘λ κ°μ²΄ νƒ€μ…(Mapped Object Type) κΈ°λ¥μ„ μ‚¬μ©ν•μ—¬ κΈ°μ΅΄ κ°μ²΄ νƒ€μ…μ„ κΈ°λ°μΌλ΅ μƒλ΅μ΄ κ°μ²΄ νƒ€μ…μ„ λ§λ“¤ μ μλ‹¤. `keyof` μ™€ ν•¨κ» μ‚¬μ©λλ©° κ°μ²΄ νƒ€μ…μ ν‚¤(ν”„λ΅νΌν‹° μ΄λ¦„)λ¥Ό μ¶”μ¶ν•λ”λ° μ‚¬μ©λλ‹¤.

μ½”λ“λ¥Ό λ°λ³µν•μ§€ μ•κ³  μ„ νƒμ μΌλ΅ λ§λ“¤ μ μλ‹¤.

```ts
type Person = {
  name: string;
  age: number;
  location: string;
};

// λ¨λ“  ν”„λ΅νΌν‹°λ¥Ό μ„ νƒμ μΌλ΅ λ§λ“λ” λ§¤ν•‘λ κ°μ²΄ νƒ€μ…
type PartialPerson = {
  [key in keyof Person]?: Person[key];
};

// PartialPerson νƒ€μ… μ‚¬μ©
const partialPerson: PartialPerson = {
  name: "Alice",
  age: 30,
};

// μμ‹μ–΄ readonlyμ™€ ? μ‚¬μ©
type Copy = {
  readonly [key in keyof Person]?: Person[key];
};
/*
	type Copy = {
	    readonly name?: string | undefined;
	    readonly age?: number | undefined;
	    readonly location?: string | undefined;
	}
*/

// μμ‹μ–΄ μ κ±°ν•λ” λ°©λ²•
type Remove = {
  -readonly [key in keyof Copy]-?: Copy[key];
};
/*
	μμ‹μ–΄ `readonly`μ™€ `?` μ•μ— `-`λ¥Ό λ¶™μ—¬μ„ readonlyμ™€ ? μμ‹μ–΄κ°€ μ κ±°λμ—λ‹¤.
	type μμ‹μ–΄μ κ±° = {
	    name: string;
	    age: number;
	    location: string;
	}
*/

// as μμ•½μ–΄λ¥Ό ν†µν•΄ μ†μ„± μ΄λ¦„μ„ λ°”κΏ€μ§€ μ •ν•  μ μλ‹¤.
// Capitalizeλ” νƒ€μ…μ¤ν¬λ¦½νΈμ—μ„ μ κ³µν•λ” νƒ€μ…μΌλ΅ λ¬Έμμ—΄μ μ²« λ²μ§Έ μλ¦¬λ¥Ό λ€λ¬Έμν™”ν•λ‹¤.
// keyκ°€ μ„λ²„μ—μ„λ” λ€λ¬Έμλ΅ λ‚΄λ ¤μ¤κ³  ν”„λ΅ νΈμ—μ„λ” μ†λ¬Έμλ΅ λ‚΄λ ¤μ¬ λ• μ“°λ©΄ μΆ‹μ„ κ²ƒ κ°™λ‹¤.
type CapitalizeCopy = {
  [key in keyof Person as Capitalize<key>]: Person[key];
};
/*
	type CapitalizeCopy = {  
		Name: string;  
		Age: number;  
		Location: string;  
	}
*/
```

# 2.11 νƒ€μ…μ„ μ§‘ν•©μΌλ΅ μƒκ°ν•μ (μ λ‹μ–Έ, μΈν„°μ„Ήμ…)

κµμ§‘ν•©μ„ λ‚νƒ€λ‚΄λ” μ—°μ‚°μλ” `&`μ΄λ‹¤. νƒ€μ…μ„ μ§‘ν•©μΌλ΅ μƒκ°ν•λ©΄ μ „μ²΄μ§‘ν•©μ€ unknown, κ³µμ§‘ν•©μ€ neverλ΅ μƒκ°ν•  μ μλ‹¤. &μ€ κµμ§‘ν•©, |λ” ν•©μ§‘ν•©μ΄ λλ‹¤.

null/undefinedλ¥Ό μ μ™Έν• μ›μ‹ μλ£ν•κ³Ό λΉ„μ–΄ μμ§€ μ•μ€ κ°μ²΄λ¥Ό & μ—°μ‚°ν•  λ• neverκ°€ λμ§€ μ•λ”λ‹¤.

# 2.12 νƒ€μ…λ„ μƒμ†μ΄ κ°€λ¥ν•λ‹¤.

extends μμ•½μ–΄λ¥Ό μ‚¬μ©ν•μ—¬ κΈ°μ΅΄ νƒ€μ…μ„ μƒμ†ν•  μ μλ‹¤. μ¤‘λ³µμΌλ΅ μ„ μ–Έν•λ” κ²ƒμ„ λ§‰μ„ μ μλ‹¤.
νƒ€μ… λ³„μΉ­λ„ κµμ§‘ν•©μ„ λ»ν•λ” `&`λ¥Ό μ‚¬μ©ν•μ—¬ μƒμ†μ΄ κ°€λ¥ν•λ‹¤.

```ts
type Animal = {
  name: string;
};

type Dog = Animal & {
  bark(): void;
};

type Cat = Animal & {
  meow(): void;
};

type Name = Cat["name"];
```

νƒ€μ… λ³„μΉ­μ΄ μΈν„°νμ΄μ¤λ¥Ό μƒμ†ν•  μ μκ³ , μΈν„°νμ΄μ¤κ°€ νƒ€μ… λ³„μΉ­μ„ μƒμ†ν•  μλ„ μλ‹¤.

```ts
interface Animal {
  name: string;
}

type Cat = Animal & {
  meow(): void;
};
```

```ts
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}
```

ν• λ²μ— μ—¬λ¬ νƒ€μ…μ„ μƒμ†ν•  μ μκ³ , μƒμ†ν•  λ• λ¶€λ¨ μ†μ„±μ νƒ€μ…μ„ λ³€κ²½ν•  μ μλ‹¤. λ‹¨, μ™„μ „ν λ‹¤λ¥Έ νƒ€μ…μΌλ΅ λ³€κ²½ν•λ©΄ μ—λ¬κ°€ λ°μƒν•λ‹¤.

```tsx
type Animal = {
  name: string;
};

interface Dog extends Animal {
  bark(): void;
}

interface Cat extends Animal {
  meow(): void;
}

interface DogCat extends Dog, Cat {}
// β… λ” μΆμ€ νƒ€μ…μΌλ΅ μƒμ†ν•  μ μλ‹¤.
interface DogCat1 extends Dog, Cat {
  name: "κ°•μ•„μ§€";
}
// β μ™„μ „ν λ‹¤λ¥Έ νƒ€μ…μΌλ΅ λ³€κ²½ν•λ©΄ μ—λ¬κ°€ λ°μƒν•λ‹¤.
interface DogCat2 extends Dog, Cat {
  name: 123;
}
```

# 2.13 κ°μ²΄ κ°„μ— λ€μ…ν•  μ μλ”μ§€ ν™•μΈν•λ” λ²•μ„ λ°°μ°μ.

> [!tip]
> μΆμ€ νƒ€μ…κ³Ό λ„“μ€ νƒ€μ…μ— λ€ν•΄ μ΄ν•΄λ¥Ό ν•  κ²ƒ.

β­•οΈ μΆμ€ νƒ€μ… => λ„“μ€ νƒ€μ…
β λ„“μ€ νƒ€μ… => μΆμ€ νƒ€μ…

```ts
interface A {
  name: string;
}

interface B {
  name: string;
  age: number;
}
```

Aνƒ€μ…μ΄ Bνƒ€μ…λ³΄λ‹¤ λ” λ„“μ€ νƒ€μ…μ…λ‹λ‹¤. Bκ°€ μ½”λ“μ μ–‘κ³Ό μ¤„ μκ°€ λ” λ§μ•„μ„ Bκ°€ λ„“λ‹¤κ³  μƒκ°ν•  μ μμ§€λ§ μ½”λ“μ μ–‘κ³Ό μ¤„ μκ°€ λ” λ§μ€ μ΄μ λ” κ·Έλ§νΌ λ” κµ¬μ²΄μ μΌλ΅ μ μ—κΈ° λ•λ¬Έμ΄λ‹¤. κµ¬μ²΄μ μ΄λΌλ” κ²ƒμ€ μ΅°κ±΄μ„ λ§μ΅±ν•κΈ° λ” νλ“¤λ‹¤λ” λ»μ΄κ³ , λ” μΆμ€ νƒ€μ…μ΄λΌλ” κ²ƒμ΄λ‹¤.

νν”μ€ λ°°μ—΄λ³΄λ‹¤ μΆμ€ νƒ€μ…μ΄λ‹¤.
string[]μ΄ readonly string[]λ³΄λ‹¤ λ” μΆμ€ νƒ€μ…μ΄λ‹¤.
λ‘ κ°μ²΄κ°€ μκ³  μ†μ„±μ΄ λ™μΌν•  λ•, μ†μ„±μ΄ μµμ…”λ„μΈ κ°μ²΄κ°€ μµμ…”λ„μ΄μ§€ μ•μ€ κ°μ²΄λ³΄λ‹¤ λ” λ„“μ€ νƒ€μ…μ΄λ‹¤.
μµμ…”λ„μ΄λ€ κΈ°μ΅΄ νƒ€μ…μ— undefinedκ°€ μ λ‹μ–Έλ κ²ƒκ³Ό κ°™λ‹¤. `κΈ°μ΅΄ νƒ€μ… | undefined`κ°€ κΈ°μ΅΄ νƒ€μ…λ³΄λ‹¤ λ„“μ€ νƒ€μ…μ΄λ―€λ΅ μµμ…”λ„ κ°μ²΄κ°€ λ” λ„“μ€ νƒ€μ…μ΄λ‹¤.

## 2.13.1 κµ¬μ΅°μ  νƒ€μ΄ν•‘

νƒ€μ…μ¤ν¬λ¦½νΈμ—μ„λ” λ¨λ“  μ†μ„±μ΄ λ™μΌν•λ©΄ κ°μ²΄ νƒ€μ…μ μ΄λ¦„μ΄ λ‹¤λ¥΄λ”λΌλ„ λ™μΌν• νƒ€μ…μΌλ΅ μ·¨κΈ‰ν•λ‹¤. μ΄κ²ƒμ„ **κµ¬μ΅°μ  νƒ€μ΄ν•‘(structural typing)** μ΄λΌ ν•λ‹¤.

κµ¬μ΅°μ μΌλ΅ λ™μΌν•μ§€ μ•κ² λ§λ“¤λ ¤λ©΄ **λΈλλ“(brand) μ†μ„±**μ„ μ¶”κ°€ν•λ©΄ λλ‹¤. μ•„λμ μμ‹μ²λΌ κΌ­ `__type` μ΄ μ•„λ‹μ–΄λ„ λλ©° λ‹¤λ¥Έ μ†μ„±κ³Ό κ²ΉμΉμ§€ μ•λ” μ΄λ¦„μ΄λ©΄ λλ‹¤. λΈλλ“ μ†μ„±μ„ μ‚¬μ©ν•λ” κ²ƒμ„ λΈλλ”©(branding) ν•λ‹¤κ³  ν‘ν„ν•λ‹¤.

```tsx
interface Money {
  __type: "money";
  amount: number;
  unit: string;
}

interface Liter {
  __type: "liter";
  amount: number;
  unit: string;
}
```

# 2.14 μ λ„¤λ¦­μΌλ΅ νƒ€μ…μ„ ν•¨μμ²λΌ μ‚¬μ©ν•μ.

> [!tip]
> μ λ„¤λ¦­μ„ ν•¨μλΌκ³  μƒκ°ν•μ. ν•¨μμ λ§¤κ°λ³€μμ— νΈμ¶ν•  λ• λ„£μ€ μΈμκ°€ λ€μ‘λλ” κ²ƒμ²λΌ!

```tsx
interface Joo {
  type: "humam";
  race: "yellow";
  name: "Joo";
  age: 37;
}

interface Kiu {
  type: "humam";
  race: "yellow";
  name: "Kiu";
  age: 20;
}
```

typeκ³Ό race μ†μ„±μ νƒ€μ…μ€ λ™μΌν•λ°, nameκ³Ό age μ†μ„±μ νƒ€μ…μ€ λ‹¤λ¥΄λ‹¤. μ λ„¤λ¦­(Generic)μ„ μ‚¬μ©ν•μ—¬ μ¤‘λ³µμ„ μ κ±°ν•  μ μλ‹¤.

```ts
interface Person<N, A> {
  type: "humam";
  race: "yellow";
  name: N;
  age: A;
}

interface Joo extends Person<"Joo", 37> {}
interface Kiu extends Person<"Kiu", 20> {}
```

μ λ„¤λ¦­ ν‘κΈ°λ” `<>`λ΅ ν•λ©° μΈν„°νμ΄μ¤ μ΄λ¦„ λ°”λ΅ λ’¤μ— μ„μΉν•λ‹¤. <>μ•μ— νƒ€μ… λ§¤κ°λ³€μ(Type Parameter)λ¥Ό λ„£μΌλ©΄ λλ‹¤. μ„ μ–Έν• μ λ„¤λ¦­μ„ μ‚¬μ©ν•  λ•λ” λ§¤κ°λ³€μμ— λ€μ‘ν•λ” μ‹¤μ  νƒ€μ… μΈμ(Type Argument)λ¥Ό λ„£μΌλ©΄ λλ‹¤.

β—οΈ μ λ„¤λ¦­μ€ λ‹¤μκ³Ό κ°™μ€ μ„μΉλ¥Ό μ‚¬μ©ν•΄μ•Ό ν•λ‹¤. (μ•”κΈ°ν•  κ²ƒ)

- `interface μ΄λ¦„<νƒ€μ… λ§¤κ°λ³€μλ“¤> {...}`
- `type μ΄λ¦„<νƒ€μ… λ§¤κ°λ³€μλ“¤> = {...}`
- `class μ΄λ¦„<νƒ€μ… λ§¤κ°λ³€μλ“¤> {...}`
- `function μ΄λ¦„<νƒ€μ… λ§¤κ°λ³„μλ“¤>(...) {...}`
- `const ν•¨μμ΄λ¦„ = <νƒ€μ… λ§¤κ°λ³€μλ“¤>(...) => {...}`

μ λ„¤λ¦­μ— μ§μ ‘ νƒ€μ…μ„ λ„£μ§€ μ•μ•„λ„ μ¶”λ΅ μ„ ν†µν•΄ νƒ€μ…μ„ μ• μ μμΌλ©°, μ‹¤μ λ΅ μ§μ ‘ λ„£μ§€ μ•μ€ κ²½μ°κ°€ λ” λ§λ‹¤.

```tsx
function values<const T>(initial: T[]) {
  return {
    hasValue(value: T) {
      return initial.includes(value);
    },
  };
}

const saveValues = values(["a", "b", "c"]);
saveValues.hasValue("x");
```

> [!question]
> μ—¬κΈ°μ„ μ΄μ•ΌκΈ°ν•λ” μƒμ νƒ€μ… λ§¤κ°λ³€μλ” λ¬΄μ—‡μΌκΉ?
> μ λ‹μ–ΈμΌλ΅ μ¶”λ΅ ν•λ‹¤λ” κ±΄ λ­μ§€??

## 2.14.1 μ λ„¤λ¦­μ— μ μ•½ κ±ΈκΈ°

νƒ€μ… λ§¤κ°λ³€μμ— μ μ•½(constraint)μ„ μ‚¬μ©ν•  μ μλ‹¤. νƒ€μ… λ§¤κ°λ³€μ Aμ νƒ€μ…μ€ μ«μ νƒ€μ…μ΄μ–΄μ•Ό ν•λ‹¤λ” λ»μ΄λ‹¤.
μ μ•½μ΄ κ±Έλ¦¬λ©΄ μ μ•½μ— μ–΄κΈ‹λ‚λ” νƒ€μ…μ€ μ…λ ¥ν•  μ μ—†μ§€λ§ μ μ•½λ³΄λ‹¤ λ” κµ¬μ²΄μ μΈ νƒ€μ…μ€ μ…λ ¥ν•  μ μλ‹¤.

```ts
interface Example<A extends number, B = string> {
  // B = νƒ€μ… λ°©μ‹μΌλ΅ κΈ°λ³Έκ°’μ„ μ„¤μ •ν•  μ μλ‹¤.
  a: A;
  b: B;
}

type UseCase1 = Example<string, boolean>;
// Type 'string' does not satisfy the constraint 'number'.
// number νƒ€μ…μΌλ΅ μ μ•½μ„ ν–μΌλ―€λ΅ μ μ•½μ— μ–΄κΈ‹λ‚λ” νƒ€μ…μ„ μ…λ ¥ν•λ©΄ μ—λ¬κ°€ λ‚λ‹¤.

type UseCase2 = Example<1, boolean>;
// number νƒ€μ…μ κµ¬μ²΄μ μΈ νƒ€μ…μΈ λ¦¬ν„°λ΄ 1μ€ μ…λ ¥ν•  μ μλ‹¤.
type UseCase3 = Example<number>;
// κΈ°λ³Έκ°’μ„ μ„¤μ •ν•μ€κΈ° λ•λ¬Έμ— Bλ¥Ό μ…λ ¥ν•μ§€ μ•μ•„λ„ λλ‹¤.

const useCase3: UseCase3 = { a: 1, b: false };
// Type 'boolean' is not assignable to type 'string'.
// The expected type comes from property 'b' which is declared here on type
// νƒ€μ… λ³„μΉ­μ„ μ„ μ–Έν•  λ• κΈ°λ³Έκ°’μΈ string νƒ€μ…μΌλ΅ μ„¤μ •ν–μΌλ―€λ΅ boolean νƒ€μ…μ„ λ„£μ–΄μ„ μ—λ¬κ°€ λ‚¬λ‹¤.
```

ν•λ‚μ νƒ€μ… λ§¤κ°λ³€μκ°€ λ‹¤λ¥Έ νƒ€μ… λ§¤κ°λ³€μμ μ μ•½μ΄ λ  μ μλ‹¤.

```ts
interface Example<A, B extends A> {
  // B νƒ€μ… λ§¤κ°λ³€μλ” A νƒ€μ…μ΄μ–΄μ•Ό ν•λ‹¤.
  a: A;
  b: B;
}

type UseCase1 = Example<string, number>;
// Type 'number' does not satisfy the constraint 'string'.
type UseCase2 = Example<string, "123">;
type UseCase3 = Example<number, 123>;
```

μμ£Όμ“°λ” μ μ•½λ“¤μ΄ μ΅΄μ¬ν•λ‹¤. κ°κ° νƒ€μ… λ§¤κ°λ³€μκ°€ κ°μ²΄, λ°°μ—΄, ν•¨μ, μƒμ„±μ, μ†μ„±μ ν‚¤μ—¬μ•Ό ν•λ‹¤λ” μ μ•½μ„ λ‚νƒ€λ‚Έλ‹¤.

```ts
<T extends object> // λ¨λ“  κ°μ²΄
<T extends any[]> // λ¨λ“  λ°°μ—΄
<T extends (...args: any) => any> // λ¨λ“  ν•¨μ
<T extends abstract new (...args: any) => any> // μƒμ„±μ νƒ€μ…
<T extends keyof any> // string | number | symbol
```
